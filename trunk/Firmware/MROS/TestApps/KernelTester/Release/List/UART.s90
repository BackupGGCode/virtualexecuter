        NAME UART

        RTMODEL "__64bit_doubles", "disabled"
        RTMODEL "__cpu", "3"
        RTMODEL "__cpu_name", "AT90Mega32"
        RTMODEL "__enhanced_core", "enabled"
        RTMODEL "__has_elpm", "false"
        RTMODEL "__memory_model", "2"
        RTMODEL "__rt_version", "2.30"

        RSEG CSTACK:DATA:NOROOT(0)
        RSEG RSTACK:DATA:NOROOT(0)

        EXTERN ?UC_DIVMOD_L01

        PUBLIC UART_BytesReady
        FUNCTION UART_BytesReady,0203H
        PUBLIC UART_Init
        FUNCTION UART_Init,0203H
        PUBLIC UART_ReadByte
        FUNCTION UART_ReadByte,0203H
        PUBLIC UART_ReadBytes
        FUNCTION UART_ReadBytes,021203H
        LOCFRAME CSTACK, 3, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC UART_SetBaudrate
        FUNCTION UART_SetBaudrate,0203H
        PUBLIC UART_WriteByte
        FUNCTION UART_WriteByte,0203H
        PUBLIC UART_WriteBytes
        FUNCTION UART_WriteBytes,021203H
        LOCFRAME CSTACK, 3, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC UART_WritePointer
        FUNCTION UART_WritePointer,021203H
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC UART_WriteString
        FUNCTION UART_WriteString,021203H
        LOCFRAME CSTACK, 3, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC UART_WriteString_P
        FUNCTION UART_WriteString_P,021203H
        LOCFRAME CSTACK, 3, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC UART_WriteValueUnsignedChar
        FUNCTION UART_WriteValueUnsignedChar,021203H
        LOCFRAME CSTACK, 1, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCTION WriteHexDigit,021203H
        LOCFRAME RSTACK, 2, STACK
        PUBWEAK _A_UBRRH
        PUBWEAK _A_UBRRL
        PUBWEAK _A_UCSRA
        PUBWEAK _A_UCSRB
        PUBWEAK _A_UDR
        PUBWEAK __?EEARH
        PUBWEAK __?EEARL
        PUBWEAK __?EECR
        PUBWEAK __?EEDR
        PUBLIC getc
        FUNCTION getc,021203H
        LOCFRAME RSTACK, 2, STACK
        PUBLIC putc
        FUNCTION putc,021203H
        LOCFRAME RSTACK, 2, STACK
        PUBLIC putchar
        FUNCTION putchar,021203H
        LOCFRAME RSTACK, 2, STACK
;     1 #include "UART.h"

        ASEGN ABSOLUTE:DATA:NOROOT,029H
; union <unnamed> volatile __io _A_UBRRL;
_A_UBRRL:
	DS 1

        ASEGN ABSOLUTE:DATA:NOROOT,02aH
; union <unnamed> volatile __io _A_UCSRB;
_A_UCSRB:
	DS 1

        ASEGN ABSOLUTE:DATA:NOROOT,02bH
; union <unnamed> volatile __io _A_UCSRA;
_A_UCSRA:
	DS 1

        ASEGN ABSOLUTE:DATA:NOROOT,02cH
; union <unnamed> volatile __io _A_UDR;
_A_UDR:
	DS 1

        ASEGN ABSOLUTE:DATA:NOROOT,040H
; union <unnamed> volatile __io _A_UBRRH;
_A_UBRRH:
	DS 1
;     2 
;     3 #define SEND_CRLF
;     4 
;     5 #if defined(BUFFERED_UART_)
;     6 static unsigned char RxBuffer[RX_BUFFER_SIZE];
;     7 static unsigned char RxBufferIn=0;
;     8 static unsigned char RxBufferOut=0;
;     9 static unsigned char RxBufferFull=0;
;    10 
;    11 static unsigned char TxBuffer[TX_BUFFER_SIZE];
;    12 static unsigned char TxBufferIn=0;
;    13 static unsigned char TxBufferOut=0;
;    14 static unsigned char TxBufferFull=0;
;    15 #endif
;    16 
;    17 
;    18 
;    19 static void WriteHexDigit(unsigned char value);
;    20 
;    21 
;    22 /**************************************************************
;    23 
;    24 **************************************************************/

        RSEG CODE:CODE:NOROOT(1)
;    25 void UART_Init(unsigned short baudrate)
;    26 {
;    27 #if defined(__IOM64_H) 
;    28 	UBRR0H=(baudrate>>8);
;    29 	UBRR0L=(baudrate&0xff);
;    30 	UCSR0A=(1<<U2X0);
;    31 #elif defined(__IOM32_H) || defined(__IOM8_H)
;    32 	UBRRH=(baudrate>>8);
; __nearfunc void UART_Init(unsigned short);
UART_Init:
	OUT	0x20,R17
;    33 	UBRRL=(baudrate&0xff);
	OUT	0x09,R16
;    34 	UCSRA=(1<<U2X);
	LDI	R16,2
	OUT	0x0B,R16
;    35 #else
;    36 #error Module UART_ does not support the selected processor!
;    37 #endif
;    38 
;    39 #if defined(BUFFERED_UART_)
;    40 
;    41 #if defined(__IOM64_H) 
;    42 	UCSR0B=(1<<RXCIE0)|(1<<RXEN0)|(1<<TXEN0);
;    43 #elif defined(__IOM32_H) || defined(__IOM8_H)
;    44 	UCSRB=(1<<RXCIE)|(1<<RXEN)|(1<<TXEN);
;    45 #else
;    46 #error Module UART_ does not support the selected processor!
;    47 #endif
;    48 
;    49 #else
;    50 
;    51 #if defined(__IOM64_H) 
;    52 	UCSR0B=(1<<RXEN0)|(1<<TXEN0);
;    53 #elif defined(__IOM32_H) || defined(__IOM8_H)
;    54 	UCSRB=(1<<RXEN)|(1<<TXEN);
	LDI	R16,24
	OUT	0x0A,R16
;    55 #else
;    56 #error Module UART_ does not support the selected processor!
;    57 #endif
;    58 
;    59 #endif
;    60 
;    61 }
	RET
;    62 
;    63 
;    64 /**************************************************************
;    65 
;    66 **************************************************************/

        RSEG CODE:CODE:NOROOT(1)
;    67 void UART_SetBaudrate(unsigned short baudrate)
;    68 {
;    69 #if defined(__IOM64_H) 
;    70 	UBRR0H=(baudrate>>8);
;    71 	UBRR0L=(baudrate&0xff);
;    72 #elif defined(__IOM32_H) || defined(__IOM8_H)
;    73 	UBRRH=(baudrate>>8);
; __nearfunc void UART_SetBaudrate(unsigned short);
UART_SetBaudrate:
	OUT	0x20,R17
;    74 	UBRRL=(baudrate&0xff);
	OUT	0x09,R16
;    75 #else
;    76 #error Module UART_ does not support the selected processor!
;    77 #endif
;    78 }
	RET
;    79 
;    80 /**************************************************************
;    81 
;    82 **************************************************************/

        RSEG CODE:CODE:NOROOT(1)
;    83 unsigned char UART_BytesReady(void)
;    84 {
;    85 #if defined(BUFFERED_UART_)
;    86 	if(RxBufferFull)
;    87 		return RX_BUFFER_SIZE;
;    88 	else
;    89 	{
;    90 		if(RxBufferIn==RxBufferOut)
;    91 			return 0;
;    92 		else if(RxBufferIn>RxBufferOut)
;    93 			return (RxBufferIn-RxBufferOut);
;    94 		else
;    95 			return (RX_BUFFER_SIZE-(RxBufferOut-RxBufferIn));
;    96 	}
;    97 
;    98 #else
;    99 
;   100 #if defined(__IOM64_H)
;   101 	return ((UCSR0A&(1<<RXC0))!=0);
;   102 #elif defined(__IOM32_H) || defined(__IOM8_H)
;   103 	return ((UCSRA&(1<<RXC))!=0);
; __nearfunc unsigned char UART_BytesReady();
UART_BytesReady:
	SBIS	0x0B,0x07
	RJMP	??UART_BytesReady_0
	LDI	R16,1
	RET
??UART_BytesReady_0:
	LDI	R16,0
	RET
;   104 #else
;   105 #error Module UART_ does not support the selected processor!
;   106 #endif
;   107 
;   108 #endif
;   109 }
;   110 
;   111 
;   112 /**************************************************************
;   113 
;   114 **************************************************************/

        RSEG CODE:CODE:NOROOT(1)
;   115 unsigned char UART_ReadByte(void)
;   116 {
;   117 #if defined(BUFFERED_UART_)
;   118 unsigned char Temp;
;   119 
;   120 	while(UART_ByteSReady()==0);
;   121 
;   122 	Temp=RxBuffer[RxBufferOut++];
;   123 	if(RxBufferOut>=RX_BUFFER_SIZE)
;   124 		RxBufferOut=0;
;   125 	RxBufferFull=0;
;   126 	return Temp;
;   127 
;   128 #else
;   129 
;   130 #if defined(__IOM64_H)
;   131 	while(!(UCSR0A&(1<<RXC0)));
;   132 	return UDR0;
;   133 #elif defined(__IOM32_H) || defined(__IOM8_H)
;   134 	while(!(UCSRA&(1<<RXC)));
; __nearfunc unsigned char UART_ReadByte();
UART_ReadByte:
??UART_ReadByte_0:
	SBIS	0x0B,0x07
	RJMP	??UART_ReadByte_0
;   135 	return UDR;
	IN	R16,0x0C
	RET
;   136 #else
;   137 #error Module UART_ does not support the selected processor!
;   138 #endif
;   139 
;   140 #endif
;   141 }
;   142 
;   143 
;   144 /**************************************************************
;   145 
;   146 **************************************************************/

        RSEG CODE:CODE:NOROOT(1)
;   147 void UART_ReadBytes(unsigned char *buffer, unsigned char length)
;   148 {
; __nearfunc void UART_ReadBytes(unsigned char *, unsigned char);
UART_ReadBytes:
        FUNCALL UART_ReadBytes, UART_ReadByte
        LOCFRAME CSTACK, 3, STACK
        LOCFRAME RSTACK, 2, STACK
	ST	-Y,R27
	ST	-Y,R26
	ST	-Y,R24
	MOVW	R27 : R26,R17 : R16
	MOV	R24,R18
	RJMP	??UART_ReadBytes_0
;   149 	while(length)
;   150 	{
;   151 		*buffer++=UART_ReadByte();
??UART_ReadBytes_1:
	RCALL	UART_ReadByte
	ST	X+,R16
;   152 		length--;
	DEC	R24
??UART_ReadBytes_0:
	TST	R24
	BRNE	??UART_ReadBytes_1
;   153 	}
;   154 }
	LD	R24,Y+
	LD	R26,Y+
	LD	R27,Y+
	RET
;   155 
;   156 
;   157 /**************************************************************
;   158 
;   159 **************************************************************/

        RSEG CODE:CODE:NOROOT(1)
;   160 void UART_WriteByte(unsigned char data)
;   161 {
;   162 #if defined(BUFFERED_UART_)
;   163 
;   164 	while(TxBufferFull);
;   165 
;   166 //	if(UCSRA&(1<<UDRE))
;   167 //		UDR=Data;
;   168 //	else
;   169 //	{
;   170 		TxBuffer[TxBufferIn++]=data;
;   171 		if(TxBufferIn>=TX_BUFFER_SIZE)
;   172 			TxBufferIn=0;
;   173 		if(TxBufferIn==TxBufferOut)
;   174 			TxBufferFull=1;
;   175 		else
;   176 			TxBufferFull=0;
;   177 		UCSRB|=(1<<UDRIE);
;   178 //	}
;   179 
;   180 #else
;   181 
;   182 #if defined(__IOM64_H)
;   183 	while(!(UCSR0A&(1<<UDRE0)));
;   184 	UDR0=data;
;   185 #elif defined(__IOM32_H) || defined(__IOM8_H)
;   186 	while(!(UCSRA&(1<<UDRE)));
; __nearfunc void UART_WriteByte(unsigned char);
UART_WriteByte:
??UART_WriteByte_0:
	SBIS	0x0B,0x05
	RJMP	??UART_WriteByte_0
;   187 	UDR=data;
	OUT	0x0C,R16
;   188 #else
;   189 #error Module UART_ does not support the selected processor!
;   190 #endif
;   191 
;   192 #endif
;   193 }
	RET
;   194 
;   195 
;   196 /**************************************************************
;   197 
;   198 **************************************************************/

        RSEG CODE:CODE:NOROOT(1)
;   199 void putc(unsigned char data)
;   200 {
;   201 	UART_WriteByte(data);
; __nearfunc void putc(unsigned char);
putc:
        FUNCALL putc, UART_WriteByte
        LOCFRAME RSTACK, 2, STACK
	RJMP	UART_WriteByte
;   202 }

        RSEG CODE:CODE:NOROOT(1)
;   203 int putchar(int data)
;   204 {
;   205 	UART_WriteByte(data);
; __nearfunc int putchar(int);
putchar:
        FUNCALL putchar, UART_WriteByte
        LOCFRAME RSTACK, 2, STACK
	RCALL	UART_WriteByte
;   206 	return 0;
	LDI	R16,0
	LDI	R17,0
	RET
;   207 }
;   208 
;   209 
;   210 /**************************************************************
;   211 
;   212 **************************************************************/

        RSEG CODE:CODE:NOROOT(1)
;   213 unsigned char getc(void)
;   214 {
;   215 	return UART_ReadByte();
; __nearfunc unsigned char getc();
getc:
        FUNCALL getc, UART_ReadByte
        LOCFRAME RSTACK, 2, STACK
	RJMP	UART_ReadByte
;   216 }
;   217 
;   218 
;   219 /**************************************************************
;   220 
;   221 **************************************************************/

        RSEG CODE:CODE:NOROOT(1)
;   222 void UART_WriteBytes(unsigned char *buffer, unsigned char length)
;   223 {
; __nearfunc void UART_WriteBytes(unsigned char *, unsigned char);
UART_WriteBytes:
        FUNCALL UART_WriteBytes, UART_WriteByte
        LOCFRAME CSTACK, 3, STACK
        LOCFRAME RSTACK, 2, STACK
	ST	-Y,R27
	ST	-Y,R26
	ST	-Y,R24
	MOVW	R27 : R26,R17 : R16
	MOV	R24,R18
	RJMP	??UART_WriteBytes_0
;   224 	while(length)
;   225 	{
;   226 		length--;
??UART_WriteBytes_1:
	DEC	R24
;   227 		UART_WriteByte(*buffer++);
	LD	R16,X+
	RCALL	UART_WriteByte
??UART_WriteBytes_0:
	TST	R24
	BRNE	??UART_WriteBytes_1
;   228 	}
;   229 }
	LD	R24,Y+
	LD	R26,Y+
	LD	R27,Y+
	RET
;   230 
;   231 
;   232 /**************************************************************
;   233 
;   234 **************************************************************/
;   235 #if defined(BUFFERED_UART_)
;   236 #pragma vector=USART_RXC_vect
;   237 __interrupt void UART__RX_Interrupt(void)
;   238 {
;   239 unsigned char temp;
;   240 
;   241 #if defined(__IOM64_H)
;   242 	temp=UDR0;
;   243 #elif defined(__IOM32_H) || defined(__IOM8_H)
;   244 	temp=UDR;
;   245 #else
;   246 #error Module UART_ does not support the selected processor!
;   247 #endif
;   248 	if(!RxBufferFull)
;   249 	{
;   250 		RxBuffer[RxBufferIn++]=temp;
;   251 		if(RxBufferIn>=RX_BUFFER_SIZE)
;   252 			RxBufferIn=0;
;   253 		if(RxBufferIn==RxBufferOut)
;   254 			RxBufferFull=1;
;   255 		else
;   256 			RxBufferFull=0;
;   257 	}
;   258 }
;   259 #endif
;   260 
;   261 
;   262 /**************************************************************
;   263 
;   264 **************************************************************/
;   265 #if defined(BUFFERED_UART_)
;   266 #pragma vector=USART_UDRE_vect
;   267 __interrupt void UART__UDRE_Interrupt(void)
;   268 {
;   269 	if(TxBufferFull || (TxBufferIn!=TxBufferOut))
;   270 	{
;   271 #if defined(__IOM64_H)
;   272 		UDR0=TxBuffer[TxBufferOut++];
;   273 #elif defined(__IOM32_H) || defined(__IOM8_H)
;   274 		UDR=TxBuffer[TxBufferOut++];
;   275 #else
;   276 #error Module UART_ does not support the selected processor!
;   277 #endif
;   278 		if(TxBufferOut>=TX_BUFFER_SIZE)
;   279 			TxBufferOut=0;
;   280 		TxBufferFull=0;
;   281 	}
;   282 	else
;   283 #if defined(__IOM64_H)
;   284 		UCSR0B&=~(1<<UDRIE0);
;   285 #elif defined(__IOM32_H) || defined(__IOM8_H)
;   286 		UCSRB&=~(1<<UDRIE);
;   287 #else
;   288 #error Module UART_ does not support the selected processor!
;   289 #endif
;   290 }
;   291 #endif
;   292 
;   293 
;   294 
;   295 /**************************************************************
;   296 
;   297 **************************************************************/

        RSEG CODE:CODE:NOROOT(1)
;   298 void UART_WriteString(char* str)
;   299 {
; __nearfunc void UART_WriteString(char *);
UART_WriteString:
        FUNCALL UART_WriteString, UART_WriteByte
        LOCFRAME CSTACK, 3, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL UART_WriteString, UART_WriteByte
        LOCFRAME CSTACK, 3, STACK
        LOCFRAME RSTACK, 2, STACK
	ST	-Y,R27
	ST	-Y,R26
	ST	-Y,R24
	MOVW	R27 : R26,R17 : R16
	RJMP	??UART_WriteString_0
;   300 unsigned char temp;
;   301 
;   302 	while(*str)
;   303 	{
;   304 		temp=*str++;
??UART_WriteString_1:
	ADIW	R27 : R26,1
;   305 		UART_WriteByte(temp);
	MOV	R16,R24
	RCALL	UART_WriteByte
;   306 #if defined(SEND_CRLF)
;   307 		if(temp==10)
	CPI	R24,10
	BRNE	??UART_WriteString_0
;   308 			UART_WriteByte(13);
	LDI	R16,13
	RCALL	UART_WriteByte
??UART_WriteString_0:
	LD	R24,X
	TST	R24
	BRNE	??UART_WriteString_1
;   309 #endif
;   310 	}
;   311 }
	LD	R24,Y+
	LD	R26,Y+
	LD	R27,Y+
	RET
;   312 
;   313 
;   314 /**************************************************************
;   315 
;   316 **************************************************************/

        RSEG CODE:CODE:NOROOT(1)
;   317 void UART_WriteString_P(string* str)
;   318 {
; __nearfunc void UART_WriteString_P(char const __flash *);
UART_WriteString_P:
        FUNCALL UART_WriteString_P, UART_WriteByte
        LOCFRAME CSTACK, 3, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL UART_WriteString_P, UART_WriteByte
        LOCFRAME CSTACK, 3, STACK
        LOCFRAME RSTACK, 2, STACK
	ST	-Y,R26
	ST	-Y,R25
	ST	-Y,R24
	MOVW	R25 : R24,R17 : R16
	RJMP	??UART_WriteString_P_0
;   319 unsigned char temp;
;   320 
;   321 	while(*str)
;   322 	{
;   323 		temp=*str++;
??UART_WriteString_P_1:
	ADIW	R25 : R24,1
;   324 		UART_WriteByte(temp);
	MOV	R16,R26
	RCALL	UART_WriteByte
;   325 #if defined(SEND_CRLF)
;   326 		if(temp==10)
	CPI	R26,10
	BRNE	??UART_WriteString_P_0
;   327 			UART_WriteByte(13);
	LDI	R16,13
	RCALL	UART_WriteByte
??UART_WriteString_P_0:
	MOVW	R31 : R30,R25 : R24
	LPM	R26,Z
	TST	R26
	BRNE	??UART_WriteString_P_1
;   328 #endif
;   329 	}
;   330 }
	LD	R24,Y+
	LD	R25,Y+
	LD	R26,Y+
	RET
;   331 
;   332 
;   333 
;   334 /**************************************************************
;   335 
;   336 **************************************************************/

        RSEG CODE:CODE:NOROOT(1)
;   337 void UART_WriteValueUnsignedChar(unsigned char value)
;   338 {
; __nearfunc void UART_WriteValueUnsignedChar(unsigned char);
UART_WriteValueUnsignedChar:
        FUNCALL UART_WriteValueUnsignedChar, UART_WriteByte
        LOCFRAME CSTACK, 1, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL UART_WriteValueUnsignedChar, UART_WriteByte
        LOCFRAME CSTACK, 1, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL UART_WriteValueUnsignedChar, UART_WriteByte
        LOCFRAME CSTACK, 1, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL UART_WriteValueUnsignedChar, UART_WriteByte
        LOCFRAME CSTACK, 1, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL UART_WriteValueUnsignedChar, UART_WriteByte
        LOCFRAME CSTACK, 1, STACK
        LOCFRAME RSTACK, 2, STACK
	ST	-Y,R24
	MOV	R24,R16
;   339 	if(value > 99)
	CPI	R24,100
	BRCS	??UART_WriteValueUnsignedChar_0
;   340 		UART_WriteByte((value / 100) + '0');
	LDI	R20,100
	CALL	?UC_DIVMOD_L01
	SUBI	R16,208
	RCALL	UART_WriteByte
	RJMP	??UART_WriteValueUnsignedChar_1
;   341 	else
;   342 		UART_WriteByte(' ');
??UART_WriteValueUnsignedChar_0:
	LDI	R16,32
	RCALL	UART_WriteByte
;   343 	
;   344 	if(value > 9)
	CPI	R24,10
	BRCS	??UART_WriteValueUnsignedChar_2
;   345 		UART_WriteByte(((value / 10) % 10) + '0');
??UART_WriteValueUnsignedChar_1:
	MOV	R16,R24
	LDI	R20,10
	CALL	?UC_DIVMOD_L01
	LDI	R20,10
	CALL	?UC_DIVMOD_L01
	MOV	R16,R20
	SUBI	R16,208
	RJMP	??UART_WriteValueUnsignedChar_3
;   346 	else
;   347 		UART_WriteByte(' ');
??UART_WriteValueUnsignedChar_2:
	LDI	R16,32
??UART_WriteValueUnsignedChar_3:
	RCALL	UART_WriteByte
;   348 	
;   349 	UART_WriteByte((value % 10) + '0');
	MOV	R16,R24
	LDI	R20,10
	CALL	?UC_DIVMOD_L01
	MOV	R16,R20
	SUBI	R16,208
	RCALL	UART_WriteByte
;   350 }
	LD	R24,Y+
	RET
;   351 
;   352 

        RSEG CODE:CODE:NOROOT(1)
;   353 void UART_WritePointer(void* pointer)
;   354 {
; __nearfunc void UART_WritePointer(void *);
UART_WritePointer:
        FUNCALL UART_WritePointer, WriteHexDigit
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL UART_WritePointer, WriteHexDigit
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL UART_WritePointer, WriteHexDigit
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL UART_WritePointer, WriteHexDigit
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
	ST	-Y,R25
	ST	-Y,R24
	MOVW	R25 : R24,R17 : R16
;   355 	WriteHexDigit((unsigned short)pointer >> 12);
	MOV	R16,R17
	LSR	R16
	LSR	R16
	LSR	R16
	LSR	R16
	RCALL	WriteHexDigit
;   356 	WriteHexDigit((unsigned short)pointer >> 8);
	MOV	R16,R25
	RCALL	WriteHexDigit
;   357 	WriteHexDigit((unsigned short)pointer >> 4);
	MOVW	R17 : R16,R25 : R24
	LSR	R17
	ROR	R16
	LSR	R17
	ROR	R16
	LSR	R17
	ROR	R16
	LSR	R17
	ROR	R16
	RCALL	WriteHexDigit
;   358 	WriteHexDigit((unsigned short)pointer);
	MOV	R16,R24
	RCALL	WriteHexDigit
;   359 }
	LD	R24,Y+
	LD	R25,Y+
	RET
;   360 
;   361 

        RSEG CODE:CODE:NOROOT(1)
;   362 static void WriteHexDigit(unsigned char value)
;   363 {
;   364 	value &= 0x0f;
; static __nearfunc void WriteHexDigit(unsigned char);
WriteHexDigit:
        FUNCALL WriteHexDigit, UART_WriteByte
        LOCFRAME RSTACK, 2, STACK
        FUNCALL WriteHexDigit, UART_WriteByte
        LOCFRAME RSTACK, 2, STACK
	ANDI	R16,0x0F
;   365 	
;   366 	if(value > 9)
	CPI	R16,10
	BRCS	??WriteHexDigit_0
;   367 		UART_WriteByte(value + 'A' - 10);
	SUBI	R16,201
	RJMP	UART_WriteByte
;   368 	else
;   369 		UART_WriteByte(value + '0');
??WriteHexDigit_0:
	SUBI	R16,208
	RJMP	UART_WriteByte
;   370 }

        ASEGN ABSOLUTE:DATA:NOROOT,01cH
__?EECR:

        ASEGN ABSOLUTE:DATA:NOROOT,01dH
__?EEDR:

        ASEGN ABSOLUTE:DATA:NOROOT,01eH
__?EEARL:

        ASEGN ABSOLUTE:DATA:NOROOT,01fH
__?EEARH:

        END
;   371 
;   372 /**************************************************************
;   373 
;   374 **************************************************************/
;   375 /*
;   376 void UART__WriteShort(unsigned short Data)
;   377 {
;   378 	if(Data>9999)
;   379 		UART_WriteByte((Data/10000)%10+'0');
;   380 	if(Data>999)
;   381 		UART_WriteByte((Data/1000)%10+'0');
;   382 	if(Data>99)
;   383 		UART_WriteByte((Data/100)%10+'0');
;   384 	if(Data>9)
;   385 		UART_WriteByte((Data/10)%10+'0');
;   386 	UART_WriteByte(Data%10+'0');
;   387 }
;   388 */
;   389 
;   390 /**************************************************************
;   391 
;   392 **************************************************************/
;   393 /*
;   394 void Flush(void)
;   395 {
;   396 	while(UART_BytesReady())
;   397 		UART_ReadByte();
;   398 }
;   399 */
; 
;      5 bytes in segment ABSOLUTE
;    334 bytes in segment CODE
; 
;    334 bytes of CODE memory
;      0 bytes of DATA memory (+ 5 bytes shared)
;
;Errors: none
;Warnings: none
