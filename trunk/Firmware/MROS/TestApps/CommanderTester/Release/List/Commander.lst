##############################################################################
#                                                                            #
#                                                      09/Mar/2008  16:57:08 #
# IAR Atmel AVR C/C++ Compiler V4.21A/W32, Evaluation Version                #
# Copyright 1996-2006 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Source file  =  f:\Projects\[Drivers]\C\MROS\Commander\Commander.c      #
#    Command line =  --string_literals_in_flash                              #
#                    f:\Projects\[Drivers]\C\MROS\Commander\Commander.c      #
#                    --cpu=m32 -ms -o f:\Projects\[Drivers]\C\MROS\TestApps\ #
#                    CommanderTester\Release\Obj\ -D NDEBUG -lC              #
#                    f:\Projects\[Drivers]\C\MROS\TestApps\CommanderTester\R #
#                    elease\List\ -lA f:\Projects\[Drivers]\C\MROS\TestApps\ #
#                    CommanderTester\Release\List\ --initializers_in_flash   #
#                    -s9 -DENABLE_BIT_DEFINITIONS -e -I                      #
#                    f:\Projects\[Drivers]\C\mros\TestApps\CommanderTester\  #
#                    -I f:\Projects\[Drivers]\C\mros\ -I "C:\Program         #
#                    Files\IAR Systems\Embedded Workbench 4.0                #
#                    Evaluation\avr\INC\" -I "C:\Program Files\IAR           #
#                    Systems\Embedded Workbench 4.0                          #
#                    Evaluation\avr\INC\CLIB\" --eeprom_size 1024            #
#    List file    =  f:\Projects\[Drivers]\C\MROS\TestApps\CommanderTester\R #
#                    elease\List\Commander.lst                               #
#    Object file  =  f:\Projects\[Drivers]\C\MROS\TestApps\CommanderTester\R #
#                    elease\Obj\Commander.r90                                #
#                                                                            #
#                                                                            #
##############################################################################

f:\Projects\[Drivers]\C\MROS\Commander\Commander.c
      1          #include <Globals.h>

   \                                 In segment ABSOLUTE, at 0x38
   \   union <unnamed> volatile __io _A_PORTB
   \                     _A_PORTB:
   \   00000000                      DS 1
      2          #include "Config.h"
      3          #include <Kernel/Kernel.h>
      4          #include "Commander.h"
      5          #include <Peripherals/UART.h>
      6          #include <strings.h>
      7          
      8          
      9          char prompt[COMMANDER_PROMPT_LENGTH] = ">";
     10          
     11          

   \                                 In segment CODE, align 2, keep-with-next
     12          void Commander_Run()
   \                     Commander_Run:
     13          {
   \   00000000   925A               ST      -Y, R5
   \   00000002   924A               ST      -Y, R4
   \   00000004   93BA               ST      -Y, R27
   \   00000006   93AA               ST      -Y, R26
   \   00000008   939A               ST      -Y, R25
   \   0000000A   938A               ST      -Y, R24
   \   0000000C                      REQUIRE ?Register_R4_is_cg_reg
   \   0000000C                      REQUIRE ?Register_R5_is_cg_reg
     14          	static bool overflow = false;
     15          	static unsigned char index = 0;
     16          	static char buffer[COMMANDER_MAX_LINE_LENGTH+1];
     17          	unsigned char data;
     18          	unsigned char i;
     19          	bool commandFound=false;
   \   0000000C   E080               LDI     R24, 0
     20          	
     21          	if(UART_BytesReady())
   \   0000000E   ........           CALL    UART_BytesReady
   \   00000012   2300               TST     R16
   \   00000014   F409               BRNE    $+2+2
   \   00000016   C086               RJMP    ??Commander_Run_0
     22          	{
     23          		data = UART_ReadByte();
   \   00000018   ........           CALL    UART_ReadByte
     24          		
     25          		if(data==0xff)		// This is where all the naughty keys go... TO IGNORE LAND!
   \   0000001C   3F0F               CPI     R16, 255
   \   0000001E   F409               BRNE    $+2+2
   \   00000020   C081               RJMP    ??Commander_Run_0
     26          		{
     27          			return;
     28          		}
     29          		if(data==0x0d)
   \   00000022   300D               CPI     R16, 13
   \   00000024   F421               BRNE    ??Commander_Run_1
     30          		{
     31          			UART_WriteByte(0x0d);
   \   00000026   E00D               LDI     R16, 13
   \   00000028   ........           CALL    UART_WriteByte
   \   0000002C   C07B               RJMP    ??Commander_Run_0
     32          		}
     33          		else if(data == 8)
   \                     ??Commander_Run_1:
   \   0000002E   ....               LDI     R26, LOW(??overflow)
   \   00000030   ....               LDI     R27, (??overflow) >> 8
   \   00000032   01FD               MOVW    R31:R30, R27:R26
   \   00000034   8121               LDD     R18, Z+1
   \   00000036   3008               CPI     R16, 8
   \   00000038   F4C1               BRNE    ??Commander_Run_2
     34          		{
     35          			if(index>0)
   \   0000003A   2322               TST     R18
   \   0000003C   F409               BRNE    $+2+2
   \   0000003E   C072               RJMP    ??Commander_Run_0
     36          			{
     37          				UART_WriteByte(8);
   \   00000040   E008               LDI     R16, 8
   \   00000042   ........           CALL    UART_WriteByte
     38          				UART_WriteByte(' ');
   \   00000046   E200               LDI     R16, 32
   \   00000048   ........           CALL    UART_WriteByte
     39          				UART_WriteByte(8);
   \   0000004C   E008               LDI     R16, 8
   \   0000004E   ........           CALL    UART_WriteByte
     40          				index--;
   \   00000052   01FD               MOVW    R31:R30, R27:R26
   \   00000054   8101               LDD     R16, Z+1
   \   00000056   950A               DEC     R16
   \   00000058   8301               STD     Z+1, R16
     41          				buffer[index]=0;
   \   0000005A   2F20               MOV     R18, R16
   \   0000005C   E030               LDI     R19, 0
   \   0000005E   01F9               MOVW    R31:R30, R19:R18
   \   00000060   ....               SUBI    R30, LOW((-(??buffer) & 0xFFFF))
   \   00000062   ....               SBCI    R31, (-(??buffer) & 0xFFFF) >> 8
   \   00000064   8380               ST      Z, R24
     42          				overflow = false;
   \                     ??Commander_Run_3:
   \   00000066   938C               ST      X, R24
   \   00000068   C05D               RJMP    ??Commander_Run_0
     43          			}
     44          		}
     45          		else if(data == 0x0a)
   \                     ??Commander_Run_2:
   \   0000006A   300A               CPI     R16, 10
   \   0000006C   F009               BREQ    $+2+2
   \   0000006E   C04A               RJMP    ??Commander_Run_4
     46          		{
     47          			PORTB&=~(1<<6);
   \   00000070   98C6               CBI     0x18, 0x06
     48          			UART_WriteByte(0x0a);
   \   00000072   E00A               LDI     R16, 10
   \   00000074   ........           CALL    UART_WriteByte
     49          						
     50          			if(overflow)
   \   00000078   910C               LD      R16, X
   \   0000007A   2300               TST     R16
   \   0000007C   F031               BREQ    ??Commander_Run_5
     51          			{
     52          				UART_WriteString_P("Line too long\n");
   \   0000007E   ....               LDI     R16, LOW(`?<Constant "Line too long\\n">`)
   \   00000080   ....               LDI     R17, (`?<Constant "Line too long\\n">`) >> 8
   \   00000082   ........           CALL    UART_WriteString_P
     53          				overflow=false;
   \   00000086   938C               ST      X, R24
   \   00000088   C034               RJMP    ??Commander_Run_6
     54          			}
     55          			else if(index > 0)
   \                     ??Commander_Run_5:
   \   0000008A   01FD               MOVW    R31:R30, R27:R26
   \   0000008C   8121               LDD     R18, Z+1
   \   0000008E   2322               TST     R18
   \   00000090   F181               BREQ    ??Commander_Run_6
     56          			{
     57          				buffer[index++] = 0;
   \   00000092   E030               LDI     R19, 0
   \   00000094   01F9               MOVW    R31:R30, R19:R18
   \   00000096   ....               SUBI    R30, LOW((-(??buffer) & 0xFFFF))
   \   00000098   ....               SBCI    R31, (-(??buffer) & 0xFFFF) >> 8
   \   0000009A   8380               ST      Z, R24
   \   0000009C   01FD               MOVW    R31:R30, R27:R26
   \   0000009E   8101               LDD     R16, Z+1
   \   000000A0   9503               INC     R16
   \   000000A2   8301               STD     Z+1, R16
     58          	
     59          				for(i=0; i<COMMANDER_COMMAND_COUNT; i++)
   \   000000A4   ....               LDI     R16, LOW(commands)
   \   000000A6   2E40               MOV     R4, R16
   \   000000A8   ....               LDI     R16, (commands) >> 8
   \   000000AA   2E50               MOV     R5, R16
   \   000000AC   E095               LDI     R25, 5
     60          				{
     61          					if(StringCompare_PD(commands[i].name, buffer))
   \                     ??Commander_Run_7:
   \   000000AE   ....               LDI     R18, LOW(??buffer)
   \   000000B0   ....               LDI     R19, (??buffer) >> 8
   \   000000B2   01F2               MOVW    R31:R30, R5:R4
   \   000000B4   9105               LPM     R16, Z+
   \   000000B6   9114               LPM     R17, Z
   \   000000B8   ........           CALL    StringCompare_PD
   \   000000BC   2300               TST     R16
   \   000000BE   F069               BREQ    ??Commander_Run_8
     62          					{
     63          						commands[i].handler(buffer);
   \   000000C0   ....               LDI     R16, LOW(??buffer)
   \   000000C2   ....               LDI     R17, (??buffer) >> 8
   \   000000C4   01F2               MOVW    R31:R30, R5:R4
   \   000000C6   9632               ADIW    R31:R30, 2
   \   000000C8   9125               LPM     R18, Z+
   \   000000CA   9134               LPM     R19, Z
   \   000000CC   01F9               MOVW    R31:R30, R19:R18
   \   000000CE   9509               ICALL
     64          						UART_WriteString_P("\n");
   \   000000D0   ....               LDI     R16, LOW((`?<Constant "Line too long\\n">` + 15))
   \   000000D2   ....               LDI     R17, HIGH((`?<Constant "Line too long\\n">` + 15))
   \   000000D4   ........           CALL    UART_WriteString_P
     65          						commandFound=true;
   \   000000D8   E081               LDI     R24, 1
     66          					}
     67          				}
   \                     ??Commander_Run_8:
   \   000000DA   E004               LDI     R16, 4
   \   000000DC   0E40               ADD     R4, R16
   \   000000DE   E000               LDI     R16, 0
   \   000000E0   1E50               ADC     R5, R16
   \   000000E2   959A               DEC     R25
   \   000000E4   F721               BRNE    ??Commander_Run_7
     68          				
     69          				if(commandFound==false)
   \   000000E6   2388               TST     R24
   \   000000E8   F421               BRNE    ??Commander_Run_6
     70          				{
     71          					UART_WriteString_P("Unknown command\n");
   \   000000EA   ....               LDI     R16, LOW((`?<Constant "Line too long\\n">` + 17))
   \   000000EC   ....               LDI     R17, HIGH((`?<Constant "Line too long\\n">` + 17))
   \   000000EE   ........           CALL    UART_WriteString_P
     72          				}
     73          			}
     74          			
     75          			index=0;
   \                     ??Commander_Run_6:
   \   000000F2   E000               LDI     R16, 0
   \   000000F4   01FD               MOVW    R31:R30, R27:R26
   \   000000F6   8301               STD     Z+1, R16
     76          			
     77          			UART_WriteString(prompt);
   \   000000F8   9612               ADIW    R27:R26, 2
   \   000000FA   018D               MOVW    R17:R16, R27:R26
   \   000000FC   ........           CALL    UART_WriteString
     78          			PORTB|=(1<<6);
   \   00000100   9AC6               SBI     0x18, 0x06
   \   00000102   C010               RJMP    ??Commander_Run_0
     79          		}
     80          		else
     81          		{
     82          			if(index < COMMANDER_MAX_LINE_LENGTH)
   \                     ??Commander_Run_4:
   \   00000104   3322               CPI     R18, 50
   \   00000106   F460               BRCC    ??Commander_Run_9
     83          			{
     84          				buffer[index++] = data;
   \   00000108   E030               LDI     R19, 0
   \   0000010A   01F9               MOVW    R31:R30, R19:R18
   \   0000010C   ....               SUBI    R30, LOW((-(??buffer) & 0xFFFF))
   \   0000010E   ....               SBCI    R31, (-(??buffer) & 0xFFFF) >> 8
   \   00000110   8300               ST      Z, R16
   \   00000112   01FD               MOVW    R31:R30, R27:R26
   \   00000114   8111               LDD     R17, Z+1
   \   00000116   9513               INC     R17
   \   00000118   8311               STD     Z+1, R17
     85          				UART_WriteByte(data);
   \   0000011A   ........           CALL    UART_WriteByte
     86          				overflow = false;
   \   0000011E   CFA3               RJMP    ??Commander_Run_3
     87          			}
     88          			else
     89          			{
     90          				overflow = true;
   \                     ??Commander_Run_9:
   \   00000120   E001               LDI     R16, 1
   \   00000122   930C               ST      X, R16
   \                     ??Commander_Run_0:
   \   00000124   9189               LD      R24, Y+
   \   00000126   9199               LD      R25, Y+
   \   00000128   91A9               LD      R26, Y+
   \   0000012A   91B9               LD      R27, Y+
   \   0000012C   9049               LD      R4, Y+
   \   0000012E   9059               LD      R5, Y+
   \   00000130   9508               RET
     91          			}
     92          		}
     93          	}
     94          }

   \                                 In segment NEAR_I, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_I>`
   \                     ??overflow:
   \   00000000                      DS 1
   \   00000001                      REQUIRE `?<Initializer for overflow>`
   \   00000001                      DS 1
   \   00000002                      REQUIRE `?<Initializer for index>`
   \                     prompt:
   \   00000002                      DS 4
   \   00000006                      REQUIRE `?<Initializer for prompt>`

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
   \                     ??buffer:
   \   00000000                      DS 51

   \                                 In segment NEAR_ID, align 1, keep-with-next
   \                     `?<Initializer for overflow>`:
   \   00000000   00                 DB 0
   \                     `?<Initializer for index>`:
   \   00000001   00                 DB 0
   \                     `?<Initializer for prompt>`:
   \   00000002   003E               DB ">"
   \   00000004   0000               DB 0, 0

   \                                 In segment NEAR_F, align 1, keep-with-next
   \                     `?<Constant "Line too long\\n">`:
   \   00000000   694C656E7420       DB "Line too long\012"
   \              6F6F6C206E6F
   \              0A6700      
   \   0000000F   000A               DB "\012"
   \   00000011   6E556E6B776F       DB "Unknown command\012"
   \              206E6F636D6D
   \              6E610A6400  

   Maximum stack usage in bytes:

     Function                CSTACK RSTACK
     --------                ------ ------
     Commander_Run               6      2
       -> UART_BytesReady        6      2
       -> UART_ReadByte          6      2
       -> UART_WriteByte         6      2
       -> UART_WriteByte         6      2
       -> UART_WriteByte         6      2
       -> UART_WriteByte         6      2
       -> UART_WriteByte         6      2
       -> UART_WriteString_P     6      2
       -> StringCompare_PD       6      2
       ->   Indirect call        6      2
       -> UART_WriteString_P     6      2
       -> UART_WriteString_P     6      2
       -> UART_WriteString       6      2
       -> UART_WriteByte         6      2


   Segment part sizes:

     Function/Label                Bytes
     --------------                -----
     _A_PORTB                         1
     Commander_Run                  306
     overflow                         6
     buffer                          51
     ?<Initializer for overflow>      6
     ?<Constant "Line too long\n">   34
      Others                         12

 
   1 byte  in segment ABSOLUTE
 306 bytes in segment CODE
  12 bytes in segment INITTAB
  34 bytes in segment NEAR_F
   6 bytes in segment NEAR_I
   6 bytes in segment NEAR_ID
  51 bytes in segment NEAR_Z
 
 346 bytes of CODE memory (+ 12 bytes shared)
  57 bytes of DATA memory (+  1 byte  shared)

Errors: none
Warnings: none
