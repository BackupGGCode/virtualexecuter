//////////////////////////////////////////////////////////////////////////////
//                                                                           /
//                                                     09/Mar/2008  16:57:10 /
// IAR Atmel AVR C/C++ Compiler V4.21A/W32, Evaluation Version               /
// Copyright 1996-2006 IAR Systems. All rights reserved.                     /
//                                                                           /
//    Source file  =  f:\Projects\[Drivers]\C\MROS\Kernel\TaskManagement.c   /
//    Command line =  --string_literals_in_flash                             /
//                    f:\Projects\[Drivers]\C\MROS\Kernel\TaskManagement.c   /
//                    --cpu=m32 -ms -o f:\Projects\[Drivers]\C\MROS\TestApps /
//                    \CommanderTester\Release\Obj\ -D NDEBUG -lC            /
//                    f:\Projects\[Drivers]\C\MROS\TestApps\CommanderTester\ /
//                    Release\List\ -lA f:\Projects\[Drivers]\C\MROS\TestApp /
//                    s\CommanderTester\Release\List\                        /
//                    --initializers_in_flash -s9 -DENABLE_BIT_DEFINITIONS   /
//                    -e -I f:\Projects\[Drivers]\C\mros\TestApps\CommanderT /
//                    ester\ -I f:\Projects\[Drivers]\C\mros\ -I             /
//                    "C:\Program Files\IAR Systems\Embedded Workbench 4.0   /
//                    Evaluation\avr\INC\" -I "C:\Program Files\IAR          /
//                    Systems\Embedded Workbench 4.0                         /
//                    Evaluation\avr\INC\CLIB\" --eeprom_size 1024           /
//    List file    =  f:\Projects\[Drivers]\C\MROS\TestApps\CommanderTester\ /
//                    Release\List\TaskManagement.s90                        /
//                                                                           /
//                                                                           /
//////////////////////////////////////////////////////////////////////////////

        NAME TaskManagement

        RTMODEL "__64bit_doubles", "disabled"
        RTMODEL "__cpu", "3"
        RTMODEL "__cpu_name", "ATmega32"
        RTMODEL "__enhanced_core", "enabled"
        RTMODEL "__has_elpm", "false"
        RTMODEL "__memory_model", "2"
        RTMODEL "__rt_version", "3"

        RSEG CSTACK:DATA:NOROOT(0)
        RSEG RSTACK:DATA:NOROOT(0)

        EXTERN ?ML_SRAM_SRAM_16_L07

        PUBLIC Kernel_CreateTask
        FUNCTION Kernel_CreateTask,021203H
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC Kernel_DeleteTask
        FUNCTION Kernel_DeleteTask,0203H
        LOCFRAME CSTACK, 15, STACK
        LOCFRAME RSTACK, 4, STACK
        PUBLIC Kernel_ResumeTask
        FUNCTION Kernel_ResumeTask,021203H
        LOCFRAME RSTACK, 2, STACK
        PUBLIC Kernel_Sleep
        FUNCTION Kernel_Sleep,0203H
        LOCFRAME RSTACK, 2, STACK
        PUBLIC Kernel_SleepTask
        FUNCTION Kernel_SleepTask,0203H
        LOCFRAME RSTACK, 2, STACK
        PUBLIC Kernel_Suspend
        FUNCTION Kernel_Suspend,0203H
        LOCFRAME RSTACK, 2, STACK
        PUBLIC Kernel_SuspendTask
        FUNCTION Kernel_SuspendTask,021203H
        LOCFRAME RSTACK, 2, STACK
        PUBLIC Kernel_WakeTask
        FUNCTION Kernel_WakeTask,0203H
        LOCFRAME RSTACK, 2, STACK
        PUBWEAK __?EEARH
        PUBWEAK __?EEARL
        PUBWEAK __?EECR
        PUBWEAK __?EEDR
        
        CFI Names cfiNames0
        CFI StackFrame CFA_Y Y DATA
        CFI StackFrame CFA_SP SP DATA
        CFI VirtualResource ?RetPad:1, ?RetHigh:8, ?RetLow:8, ?Ret:17
        CFI Resource R0:8, R1:8, R2:8, R3:8, R4:8, R5:8, R6:8, R7:8, R8:8, R9:8
        CFI Resource R10:8, R11:8, R12:8, R13:8, R14:8, R15:8, R16:8, R17:8
        CFI Resource R18:8, R19:8, R20:8, R21:8, R22:8, R23:8, R24:8, R25:8
        CFI Resource R26:8, R27:8, R28:8, R29:8, R30:8, R31:8
        CFI Resource ?RetHighByteMask:8, SP:16, SPH:8, SPL:8, Y:16
        CFI ResourceParts ?Ret ?RetHigh, ?RetLow, ?RetPad
        CFI ResourceParts SP SPH, SPL
        CFI ResourceParts Y R29, R28
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 1
        CFI DataAlign 1
        CFI ReturnAddress ?Ret CODE
        CFI CFA_Y Y+0
        CFI CFA_SP SP+2
        CFI ?RetPad 0
        CFI ?RetHigh and(load(1, DATA, sub(CFA_SP, 1)), ?RetHighByteMask)
        CFI ?RetLow Frame(CFA_SP, 0)
        CFI ?Ret Concat
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 SameValue
        CFI R13 SameValue
        CFI R14 SameValue
        CFI R15 SameValue
        CFI R16 Undefined
        CFI R17 Undefined
        CFI R18 Undefined
        CFI R19 Undefined
        CFI R20 Undefined
        CFI R21 Undefined
        CFI R22 Undefined
        CFI R23 Undefined
        CFI R24 SameValue
        CFI R25 SameValue
        CFI R26 SameValue
        CFI R27 SameValue
        CFI R28 Undefined
        CFI R29 Undefined
        CFI R30 Undefined
        CFI R31 Undefined
        CFI ?RetHighByteMask SameValue
        CFI SPH Undefined
        CFI SPL Undefined
        CFI EndCommon cfiCommon0
        
        EXTERN TaskToIndex
        FUNCTION TaskToIndex,0202H
        EXTERN currentTaskIndex
        EXTERN taskQueue

// f:\Projects\[Drivers]\C\MROS\Kernel\TaskManagement.c
//    1 #include "Timer.h"
//    2 #include "Kernel.h"
//    3 #include "KernelInternals.h"
//    4 
//    5 

        RSEG CODE:CODE:NOROOT(1)
//    6 bool Kernel_CreateTask(task t)
Kernel_CreateTask:
        CFI Block cfiBlock0 Using cfiCommon0
        CFI Function Kernel_CreateTask
//    7 {
        FUNCALL Kernel_CreateTask, TaskToIndex
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ST      -Y, R25
        CFI R25 Frame(CFA_Y, -1)
        CFI CFA_Y Y+1
        ST      -Y, R24
        CFI R24 Frame(CFA_Y, -2)
        CFI CFA_Y Y+2
        MOVW    R25:R24, R17:R16
//    8 unsigned char index;
//    9 
//   10 	if(TaskToIndex(t) >= 0)																																// Abort if task is already in task queue
        CALL    TaskToIndex
        TST     R16
        BRMI    ??Kernel_CreateTask_0
//   11 	{
//   12 #if TASKER_DEBUG_LEVEL > 0
//   13 		Kernel_DebuggerEvent(DEBUG_EVENT_CREATETASK, t, DEBUG_STATUS_ALREADY_RUNNING, 0);
//   14 #endif
//   15 		return false;
??Kernel_CreateTask_1:
        LDI     R16, 0
        RJMP    ??Kernel_CreateTask_2
//   16 	}
//   17 
//   18 	for(index = 0; index < MAX_NUMBER_OF_TASKS; index++)
??Kernel_CreateTask_0:
        LDI     R18, 0
        RJMP    ??Kernel_CreateTask_3
??Kernel_CreateTask_4:
        INC     R18
        CPI     R18, 10
        BRCC    ??Kernel_CreateTask_1
//   19 	{
//   20 		if(taskQueue[index].theTask == null)
??Kernel_CreateTask_3:
        LDI     R30, LOW(taskQueue)
        LDI     R31, (taskQueue) >> 8
        LDI     R16, 13
        MUL     R16, R18
        ADD     R30, R0
        ADC     R31, R1
        LD      R20, Z
        LDD     R21, Z+1
        LDI     R16, 0
        CPI     R20, 0
        SBCI    R21, 0
        BRNE    ??Kernel_CreateTask_4
//   21 		{
//   22 			taskQueue[index].theTask = t;																											// Add task at the end of the queue
        ST      Z, R24
        STD     Z+1, R25
//   23 			taskQueue[index].state = TASK_STATE_READY;
        STD     Z+2, R16
//   24 			taskQueue[index].executionTime = 0;
        STD     Z+3, R16
        STD     Z+4, R16
        STD     Z+5, R16
        STD     Z+6, R16
//   25 			taskQueue[index].blockingMessageQueue = null;
        STD     Z+9, R16
        STD     Z+10, R16
//   26 			taskQueue[index].blockingSemaphore = null;
        STD     Z+11, R16
        STD     Z+12, R16
//   27 			taskQueue[index].timer = 0;
        STD     Z+7, R16
        STD     Z+8, R16
//   28 
//   29 #if TASKER_DEBUG_LEVEL > 0
//   30 			Kernel_DebuggerEvent(DEBUG_EVENT_CREATETASK, t, DEBUG_STATUS_OK, 0);
//   31 #endif
//   32 
//   33 			return true;
        LDI     R16, 1
??Kernel_CreateTask_2:
        LD      R24, Y+
        CFI R24 SameValue
        CFI CFA_Y Y+1
        LD      R25, Y+
        CFI R25 SameValue
        CFI CFA_Y Y+0
        RET
        CFI EndBlock cfiBlock0
//   34 		}
//   35 	}
//   36 #if TASKER_DEBUG_LEVEL > 0
//   37 	Kernel_DebuggerEvent(DEBUG_EVENT_CREATETASK, t, DEBUG_STATUS_NO_ROOM, 0);
//   38 #endif
//   39   return false;
//   40 }
//   41 
//   42 

        RSEG CODE:CODE:NOROOT(1)
//   43 bool Kernel_DeleteTask(task t)
Kernel_DeleteTask:
        CFI Block cfiBlock1 Using cfiCommon0
        CFI Function Kernel_DeleteTask
//   44 {
        MOV     R23, R27
        MOV     R2, R26
        MOV     R22, R24
        SBIW    R29:R28, 13
        CFI R23 R27
        CFI R2 R26
        CFI R22 R24
        CFI CFA_Y Y+13
//   45 unsigned char index;
//   46 
//   47 	for(index = 0; index < MAX_NUMBER_OF_TASKS; index++)
        LDI     R24, 0
//   48 	{
//   49 		if(taskQueue[index].theTask == t)																										// The task has been found
??Kernel_DeleteTask_0:
        LDI     R18, 13
        MUL     R18, R24
        MOVW    R31:R30, R1:R0
        SUBI    R30, LOW((-(taskQueue) & 0xFFFF))
        SBCI    R31, (-(taskQueue) & 0xFFFF) >> 8
        LD      R18, Z
        LDD     R19, Z+1
        CP      R18, R16
        CPC     R19, R17
        BRNE    ??Kernel_DeleteTask_1
//   50 		{
//   51 			while((index+1) < MAX_NUMBER_OF_TASKS && taskQueue[index].theTask != null)					// and move the rest of the queue one step up
??Kernel_DeleteTask_2:
        MOV     R30, R24
        LDI     R31, 0
        LDI     R26, LOW(taskQueue)
        LDI     R27, (taskQueue) >> 8
        LDI     R16, 13
        MUL     R16, R30
        ADD     R26, R0
        ADC     R27, R1
        ADIW    R31:R30, 1
        SBIW    R31:R30, 10
        BRGE    ??Kernel_DeleteTask_3
        LD      R18, X+
        LD      R19, X
        SBIW    R27:R26, 1
        CPI     R18, 0
        SBCI    R19, 0
        BREQ    ??Kernel_DeleteTask_3
//   52 			{
//   53 				taskQueue[index] = taskQueue[index+1];																								// move it
        MOVW    R19:R18, R27:R26
        SUBI    R18, 243
        SBCI    R19, 255
        MOVW    R17:R16, R29:R28
        MOVW    R31:R30, R19:R18
        LDI     R20, 13
        LDI     R21, 0
        CALL    ?ML_SRAM_SRAM_16_L07
        MOVW    R17:R16, R27:R26
        MOVW    R31:R30, R29:R28
        LDI     R20, 13
        CALL    ?ML_SRAM_SRAM_16_L07
//   54 				index++;
        INC     R24
        RJMP    ??Kernel_DeleteTask_2
//   55 			}
//   56 			taskQueue[index].theTask = null;																										// clear the last task entry
??Kernel_DeleteTask_3:
        LDI     R16, 0
        ST      X+, R16
        ST      X, R16
        SBIW    R27:R26, 1
//   57 			taskQueue[index].executionTime = 0;
        MOVW    R31:R30, R27:R26
        STD     Z+3, R16
        STD     Z+4, R16
        STD     Z+5, R16
        STD     Z+6, R16
//   58 			taskQueue[index].state = TASK_STATE_READY;
        STD     Z+2, R16
//   59 			taskQueue[index].blockingMessageQueue = null;
        STD     Z+9, R16
        STD     Z+10, R16
//   60 			taskQueue[index].blockingSemaphore = null;
        STD     Z+11, R16
        STD     Z+12, R16
//   61 			taskQueue[index].timer = 0;
        STD     Z+7, R16
        STD     Z+8, R16
//   62 #if TASKER_DEBUG_LEVEL > 0
//   63 			Kernel_DebuggerEvent(DEBUG_EVENT_DELETETASK, t, DEBUG_STATUS_OK, 0);
//   64 #endif
//   65 			return true;
        LDI     R16, 1
        RJMP    ??Kernel_DeleteTask_4
//   66 		}
//   67 	}
??Kernel_DeleteTask_1:
        INC     R24
        CPI     R24, 10
        BRCS    ??Kernel_DeleteTask_0
//   68 
//   69 #if TASKER_DEBUG_LEVEL > 0
//   70 	Kernel_DebuggerEvent(DEBUG_EVENT_DELETETASK, t, DEBUG_STATUS_NO_TASK, 0);
//   71 #endif
//   72 
//   73 	return false;
        LDI     R16, 0
??Kernel_DeleteTask_4:
        ADIW    R29:R28, 13
        CFI CFA_Y Y+0
        MOV     R24, R22
        MOV     R26, R2
        MOV     R27, R23
        RET
        CFI EndBlock cfiBlock1
//   74 }
//   75 
//   76 

        RSEG CODE:CODE:NOROOT(1)
//   77 bool Kernel_SuspendTask(task t)
Kernel_SuspendTask:
        CFI Block cfiBlock2 Using cfiCommon0
        CFI Function Kernel_SuspendTask
//   78 {
//   79 signed char index = TaskToIndex(t);
        FUNCALL Kernel_SuspendTask, TaskToIndex
        LOCFRAME RSTACK, 2, STACK
        CALL    TaskToIndex
//   80 
//   81 	if(index < 0)
        TST     R16
        BRPL    ??Kernel_SuspendTask_0
//   82 	{
//   83 #if TASKER_DEBUG_LEVEL > 0
//   84 		Kernel_DebuggerEvent(DEBUG_EVENT_SUSPENDTASK, t, DEBUG_STATUS_NO_TASK, 0);
//   85 #endif
//   86 		return false;
        LDI     R16, 0
        RET
//   87 	}
//   88 	
//   89 	taskQueue[index].state |= TASK_STATE_SUSPENDED;
??Kernel_SuspendTask_0:
        MOV     R18, R16
        MOV     R19, R16
        LSL     R19
        SBC     R19, R19
        LDI     R16, 13
        MUL     R16, R19
        MOV     R17, R0
        MUL     R16, R18
        MOV     R16, R0
        ADD     R17, R1
        MOVW    R31:R30, R17:R16
        SUBI    R30, LOW((-(taskQueue) & 0xFFFF))
        SBCI    R31, (-(taskQueue) & 0xFFFF) >> 8
        LDD     R16, Z+2
        ORI     R16, 0x01
        STD     Z+2, R16
//   90 	
//   91 #if TASKER_DEBUG_LEVEL > 0
//   92 	Kernel_DebuggerEvent(DEBUG_EVENT_SUSPENDTASK, t, DEBUG_STATUS_OK, 0);
//   93 #endif
//   94 	return true;
        LDI     R16, 1
        RET
        CFI EndBlock cfiBlock2
//   95 }
//   96 
//   97 

        RSEG CODE:CODE:NOROOT(1)
//   98 void Kernel_Suspend(void)
Kernel_Suspend:
        CFI Block cfiBlock3 Using cfiCommon0
        CFI Function Kernel_Suspend
//   99 {
//  100 	taskQueue[currentTaskIndex].state |= TASK_STATE_SUSPENDED;
        LDS     R18, currentTaskIndex
        LDI     R16, 13
        MUL     R16, R18
        MOVW    R31:R30, R1:R0
        SUBI    R30, LOW((-(taskQueue) & 0xFFFF))
        SBCI    R31, (-(taskQueue) & 0xFFFF) >> 8
        LDD     R16, Z+2
        ORI     R16, 0x01
        STD     Z+2, R16
//  101 	
//  102 #if TASKER_DEBUG_LEVEL > 0
//  103 	Kernel_DebuggerEvent(DEBUG_EVENT_SUSPENDTASK, CurrentTask(), DEBUG_STATUS_OK, 0);
//  104 #endif
//  105 }
        RET
        CFI EndBlock cfiBlock3
//  106 
//  107 

        RSEG CODE:CODE:NOROOT(1)
//  108 bool Kernel_ResumeTask(task t)
Kernel_ResumeTask:
        CFI Block cfiBlock4 Using cfiCommon0
        CFI Function Kernel_ResumeTask
//  109 {
//  110 signed char index = TaskToIndex(t);
        FUNCALL Kernel_ResumeTask, TaskToIndex
        LOCFRAME RSTACK, 2, STACK
        CALL    TaskToIndex
//  111 
//  112 	if(index < 0)
        TST     R16
        BRPL    ??Kernel_ResumeTask_0
//  113 	{
//  114 #if TASKER_DEBUG_LEVEL > 0
//  115 		Kernel_DebuggerEvent(DEBUG_EVENT_RESUMETASK, t, DEBUG_STATUS_NO_TASK, 0);
//  116 #endif
//  117 		return false;
        LDI     R16, 0
        RET
//  118 	}
//  119 
//  120 	taskQueue[index].state &= ~TASK_STATE_SUSPENDED;
??Kernel_ResumeTask_0:
        MOV     R18, R16
        MOV     R19, R16
        LSL     R19
        SBC     R19, R19
        LDI     R16, 13
        MUL     R16, R19
        MOV     R17, R0
        MUL     R16, R18
        MOV     R16, R0
        ADD     R17, R1
        MOVW    R31:R30, R17:R16
        SUBI    R30, LOW((-(taskQueue) & 0xFFFF))
        SBCI    R31, (-(taskQueue) & 0xFFFF) >> 8
        LDD     R16, Z+2
        ANDI    R16, 0xFE
        STD     Z+2, R16
//  121 #if TASKER_DEBUG_LEVEL > 0
//  122 	Kernel_DebuggerEvent(DEBUG_EVENT_RESUMETASK, t, DEBUG_STATUS_OK, 0);
//  123 #endif
//  124 	return true;
        LDI     R16, 1
        RET
        CFI EndBlock cfiBlock4
//  125 }
//  126 
//  127 

        RSEG CODE:CODE:NOROOT(1)
//  128 bool Kernel_SleepTask(task t, unsigned short time)
Kernel_SleepTask:
        CFI Block cfiBlock5 Using cfiCommon0
        CFI Function Kernel_SleepTask
//  129 {
        MOVW    R21:R20, R17:R16
//  130 unsigned char index;
//  131 
//  132 	for(index=0; index < MAX_NUMBER_OF_TASKS; index++)
        LDI     R22, 0
//  133 	{
//  134 		if(taskQueue[index].theTask == t)
??Kernel_SleepTask_0:
        LDI     R30, LOW(taskQueue)
        LDI     R31, (taskQueue) >> 8
        LDI     R16, 13
        MUL     R16, R22
        ADD     R30, R0
        ADC     R31, R1
        LD      R16, Z
        LDD     R17, Z+1
        CP      R16, R20
        CPC     R17, R21
        BRNE    ??Kernel_SleepTask_1
//  135 		{
//  136 			if(taskQueue[index].timer < time)
        LDD     R16, Z+7
        LDD     R17, Z+8
        CP      R16, R18
        CPC     R17, R19
        BRCC    ??Kernel_SleepTask_2
//  137 			{
//  138 				taskQueue[index].timer = time;
        STD     Z+7, R18
        STD     Z+8, R19
//  139 			}
//  140 #if TASKER_DEBUG_LEVEL > 0
//  141 			Kernel_DebuggerEvent(DEBUG_EVENT_SLEEPTASK, t, DEBUG_STATUS_OK, time);
//  142 #endif
//  143 			return true;
??Kernel_SleepTask_2:
        LDI     R16, 1
        RET
//  144 		}
//  145 	}
??Kernel_SleepTask_1:
        INC     R22
        CPI     R22, 10
        BRCS    ??Kernel_SleepTask_0
//  146 #if TASKER_DEBUG_LEVEL > 0
//  147 	Kernel_DebuggerEvent(DEBUG_EVENT_SLEEPTASK, t, DEBUG_STATUS_NO_TASK, time);
//  148 #endif
//  149 	return false;
        LDI     R16, 0
        RET
        CFI EndBlock cfiBlock5
//  150 }
//  151 
//  152 

        RSEG CODE:CODE:NOROOT(1)
//  153 void Kernel_Sleep(unsigned short time)
Kernel_Sleep:
        CFI Block cfiBlock6 Using cfiCommon0
        CFI Function Kernel_Sleep
//  154 {
//  155 	if(taskQueue[currentTaskIndex].timer < time)
        LDI     R30, LOW(taskQueue)
        LDI     R31, (taskQueue) >> 8
        LDS     R20, currentTaskIndex
        LDI     R18, 13
        MUL     R18, R20
        ADD     R30, R0
        ADC     R31, R1
        LDD     R18, Z+7
        LDD     R19, Z+8
        CP      R18, R16
        CPC     R19, R17
        BRCC    ??Kernel_Sleep_0
//  156 	{
//  157 		taskQueue[currentTaskIndex].timer = time;
        STD     Z+7, R16
        STD     Z+8, R17
//  158 	}
//  159 
//  160 #if TASKER_DEBUG_LEVEL > 0
//  161 	Kernel_DebuggerEvent(DEBUG_EVENT_SLEEPTASK, CurrentTask(), DEBUG_STATUS_OK, 0);
//  162 #endif
//  163 }
??Kernel_Sleep_0:
        RET
        CFI EndBlock cfiBlock6
//  164 
//  165 

        RSEG CODE:CODE:NOROOT(1)
//  166 bool Kernel_WakeTask(task t)
Kernel_WakeTask:
        CFI Block cfiBlock7 Using cfiCommon0
        CFI Function Kernel_WakeTask
//  167 {
//  168 unsigned char index;
//  169 
//  170 	for(index=0; index < MAX_NUMBER_OF_TASKS; index++)
        LDI     R20, 0
//  171 	{
//  172 		if(taskQueue[index].theTask == t)
??Kernel_WakeTask_0:
        LDI     R30, LOW(taskQueue)
        LDI     R31, (taskQueue) >> 8
        LDI     R18, 13
        MUL     R18, R20
        ADD     R30, R0
        ADC     R31, R1
        LD      R18, Z
        LDD     R19, Z+1
        CP      R18, R16
        CPC     R19, R17
        BRNE    ??Kernel_WakeTask_1
//  173 		{
//  174 			taskQueue[index].timer = 0;
        LDI     R16, 0
        STD     Z+7, R16
        STD     Z+8, R16
//  175 #if TASKER_DEBUG_LEVEL > 0
//  176 			Kernel_DebuggerEvent(DEBUG_EVENT_WAKETASK, t, DEBUG_STATUS_OK, 0);
//  177 #endif
//  178 			return true;
        LDI     R16, 1
        RET
//  179 		}
//  180 	}
??Kernel_WakeTask_1:
        INC     R20
        CPI     R20, 10
        BRCS    ??Kernel_WakeTask_0
//  181 	
//  182 #if TASKER_DEBUG_LEVEL > 0
//  183 	Kernel_DebuggerEvent(DEBUG_EVENT_WAKETASK, t, DEBUG_STATUS_NO_TASK, 0);
//  184 #endif
//  185 	return false;
        LDI     R16, 0
        RET
        CFI EndBlock cfiBlock7
//  186 }

        ASEGN ABSOLUTE:DATA:NOROOT,01cH
__?EECR:

        ASEGN ABSOLUTE:DATA:NOROOT,01dH
__?EEDR:

        ASEGN ABSOLUTE:DATA:NOROOT,01eH
__?EEARL:

        ASEGN ABSOLUTE:DATA:NOROOT,01fH
__?EEARH:

        END
// 
// 484 bytes in segment CODE
// 
// 484 bytes of CODE memory
//
//Errors: none
//Warnings: none
