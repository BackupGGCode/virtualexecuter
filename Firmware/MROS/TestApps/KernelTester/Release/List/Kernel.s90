        NAME Kernel

        RTMODEL "__64bit_doubles", "disabled"
        RTMODEL "__cpu", "3"
        RTMODEL "__cpu_name", "AT90Mega32"
        RTMODEL "__enhanced_core", "enabled"
        RTMODEL "__has_elpm", "false"
        RTMODEL "__memory_model", "2"
        RTMODEL "__rt_version", "2.30"

        RSEG CSTACK:DATA:NOROOT(0)
        RSEG NEAR_I:DATA:NOROOT(0)
        RSEG NEAR_ID:CODE:NOROOT(0)
        RSEG NEAR_Z:DATA:NOROOT(0)
        RSEG RSTACK:DATA:NOROOT(0)

        EXTERN ?need_segment_init
        EXTERN Kernel_InitHeap
        FUNCTION Kernel_InitHeap,0200H
        EXTERN Kernel_InitTimer
        FUNCTION Kernel_InitTimer,0202H

        PUBWEAK `?<Segment init: NEAR_I>`
        PUBWEAK `?<Segment init: NEAR_Z>`
        PUBLIC Kernel_Init
        FUNCTION Kernel_Init,021203H
        LOCFRAME RSTACK, 2, STACK
        PUBLIC Kernel_Run
        FUNCTION Kernel_Run,041203H
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC SystemTimer
        FUNCTION SystemTimer,0603H
        PUBLIC TaskToIndex
        FUNCTION TaskToIndex,0203H
        PUBWEAK _A_OCR0
        PUBWEAK _A_TCNT0
        PUBWEAK __?EEARH
        PUBWEAK __?EEARL
        PUBWEAK __?EECR
        PUBWEAK __?EEDR
        PUBLIC currentTaskIndex
        PUBLIC executionTimer
        PUBLIC taskQueue
        PUBLIC totalExecutionTime
;     1 #include "Kernel.h"

        ASEGN ABSOLUTE:DATA:NOROOT,052H
; union <unnamed> volatile __io _A_TCNT0;
_A_TCNT0:
	DS 1

        ASEGN ABSOLUTE:DATA:NOROOT,05cH
; union <unnamed> volatile __io _A_OCR0;
_A_OCR0:
	DS 1
;     2 #include "KernelInternals.h"
;     3 #include "Timer.h"
;     4 #include "Debugger.h"
;     5 
;     6 

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
;     7 volatile taskStruct taskQueue[MAX_NUMBER_OF_TASKS];
; struct <unnamed> volatile __near taskQueue[8];
taskQueue:
	DS 104
;     8 unsigned char currentTaskIndex = ~0;
;     9 unsigned short executionTimer;

        RSEG NEAR_I:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_I>`
;    10 unsigned long totalExecutionTime;
; unsigned long __near totalExecutionTime;
totalExecutionTime:
	DS 4
	REQUIRE `?<Initializer for totalExecutionTime>`
; unsigned short __near executionTimer;
executionTimer:
	DS 2
	REQUIRE `?<Initializer for executionTimer>`
; unsigned char __near currentTaskIndex;
currentTaskIndex:
	DS 1
	REQUIRE `?<Initializer for currentTaskIndex>`
	DS 1
	REQUIRE `?<Initializer for tcnt>`
;    11 #if TASKER_DEBUG_LEVEL > 1
;    12 unsigned short debugTimer = 0;
;    13 #endif
;    14 
;    15 
;    16 /***************************************************************************************************************************
;    17 	Removes all tasks from the task queue
;    18 ***************************************************************************************************************************/

        RSEG CODE:CODE:NOROOT(1)
;    19 void Kernel_Init(void)
;    20 {
;    21 unsigned short index;
;    22 
;    23 #if TASKER_DEBUG_LEVEL > 0
;    24 	Kernel_InitDebugger();
;    25 #endif
;    26 
;    27 #if defined(HEAP_SIZE)
;    28 	Kernel_InitHeap();
; __nearfunc void Kernel_Init();
Kernel_Init:
        FUNCALL Kernel_Init, Kernel_InitHeap
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Kernel_Init, Kernel_InitTimer
        LOCFRAME RSTACK, 2, STACK
	CALL	Kernel_InitHeap
;    29 #endif
;    30 
;    31 	// Clearing the task queue this way takes up less code space than using initializer ( ={0} )!
;    32 	for(index = 0; index < MAX_NUMBER_OF_TASKS; index++)																	// Clear all task index'
	LDI	R30,LOW(taskQueue)
	LDI	R31,(taskQueue) >> 8
	LDI	R16,8
;    33 	{
;    34 		taskQueue[index].theTask = null;
??Kernel_Init_0:
	LDI	R18,0
	ST	Z,R18
	STD	Z+1,R18
;    35 		taskQueue[index].executionTime = 0;
	STD	Z+3,R18
	STD	Z+4,R18
	STD	Z+5,R18
	STD	Z+6,R18
;    36 		taskQueue[index].state = TASK_STATE_READY;
	STD	Z+2,R18
;    37 		taskQueue[index].blockingMessageQueue = null;
	STD	Z+9,R18
	STD	Z+10,R18
;    38 		taskQueue[index].blockingSemaphore = null;
	STD	Z+11,R18
	STD	Z+12,R18
;    39 		taskQueue[index].timer = 0;
	STD	Z+7,R18
	STD	Z+8,R18
	ADIW	R31 : R30,13
	DEC	R16
	BRNE	??Kernel_Init_0
;    40 	}
;    41 	
;    42 	Kernel_InitTimer(SystemTimer);
	LDI	R16,LOW(SystemTimer/2)
	LDI	R17,(SystemTimer/2) >> 8
	CALL	Kernel_InitTimer
;    43 	
;    44 	NonCritical();
	SEI
;    45 	
;    46 #if TASKER_DEBUG_LEVEL > 0
;    47 	Kernel_DebuggerEvent(DEBUG_EVENT_INITSCHEDULER, null, DEBUG_STATUS_OK, 0);
;    48 #endif
;    49 }
	RET
;    50 
;    51 
;    52 /***************************************************************************************************************************
;    53 	Loops through the task queue and calls the tasks
;    54 ***************************************************************************************************************************/

        RSEG CODE:CODE:NOROOT(1)
;    55 void Kernel_Run(void)
;    56 {
; __nearfunc void Kernel_Run();
Kernel_Run:
        FUNCALL Kernel_Run
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
	ST	-Y,R27
	ST	-Y,R26
	RJMP	??Kernel_Run_0
;    57 #if TASKER_DEBUG_LEVEL > 1
;    58 static unsigned char debugIndex = 0;
;    59 #endif
;    60 
;    61 static unsigned char tcnt;
;    62 
;    63 #if TASKER_DEBUG_LEVEL > 0
;    64 	Kernel_DebuggerEvent(DEBUG_EVENT_RUNSCHEDULER, null, DEBUG_STATUS_OK, 0);
;    65 #endif
;    66 		
;    67 	while(true)												// Run scheduler forever
;    68 	{
;    69 //		Critical();
;    70 		
;    71 		do
;    72 		{
;    73 			NonCritical();
;    74 			__no_operation();
;    75 			Critical();
;    76 			
;    77 			currentTaskIndex++;
;    78 			
;    79 			if(currentTaskIndex >= MAX_NUMBER_OF_TASKS || taskQueue[currentTaskIndex].theTask == null)
;    80 			{
;    81 				currentTaskIndex = 0;
;    82 			}
;    83 		} while(taskQueue[currentTaskIndex].state != TASK_STATE_READY || taskQueue[currentTaskIndex].timer > 0 ||
;    84 						taskQueue[currentTaskIndex].blockingMessageQueue != null || taskQueue[currentTaskIndex].blockingSemaphore != null );
;    85 		
;    86 		executionTimer = 0;
;    87 		tcnt = TCNT0;
;    88 		
;    89 		NonCritical();
;    90 		
;    91 		taskQueue[currentTaskIndex].theTask();																							// Execute the task
;    92 		
;    93 		Critical();
;    94 		
;    95 		executionTimer *= OCR0;
;    96 		if(tcnt >= TCNT0)
;    97 			executionTimer += ((OCR0+1)-tcnt)+TCNT0;
;    98 		else
;    99 			executionTimer += TCNT0-tcnt;
??Kernel_Run_1:
	IN	R18,0x32
	LDI	R19,0
	MOVW	R31 : R30,R27 : R26
	LDD	R16,Z+7
	SUB	R18,R16
	SBCI	R19,0
??Kernel_Run_2:
	LDD	R16,Z+4
	LDD	R17,Z+5
	ADD	R16,R18
	ADC	R17,R19
	STD	Z+4,R16
	STD	Z+5,R17
;   100 		
;   101 		totalExecutionTime += executionTimer;
	MOVW	R31 : R30,R27 : R26
	LDD	R16,Z+4
	LDD	R17,Z+5
	LDI	R18,0
	LD	R20,X+
	LD	R21,X+
	LD	R22,X+
	LD	R23,X
	ADD	R20,R16
	ADC	R21,R17
	ADC	R22,R18
	ADC	R23,R18
	ST	X,R23
	ST	-X,R22
	ST	-X,R21
	ST	-X,R20
;   102 		
;   103 		taskQueue[currentTaskIndex].executionTime += executionTimer;
	LDS	R22,currentTaskIndex
	LDI	R23,0
	LDI	R20,13
	LDI	R21,0
	MUL	R21,R22
	MOV	R21,R0
	MUL	R20,R23
	ADD	R21,R0
	MUL	R20,R22
	MOV	R20,R0
	ADD	R21,R1
	MOVW	R31 : R30,R21 : R20
	SUBI	R30,LOW((-(taskQueue) & 0xFFFF))
	SBCI	R31,(-(taskQueue) & 0xFFFF) >> 8
	LDD	R20,Z+3
	LDD	R21,Z+4
	LDD	R22,Z+5
	LDD	R23,Z+6
	ADD	R20,R16
	ADC	R21,R17
	ADC	R22,R18
	ADC	R23,R18
	STD	Z+3,R20
	STD	Z+4,R21
	STD	Z+5,R22
	STD	Z+6,R23
??Kernel_Run_0:
	SEI
	NOP
	CLI
	LDI	R26,LOW(totalExecutionTime)
	LDI	R27,(totalExecutionTime) >> 8
	LDI	R30,LOW(totalExecutionTime)
	LDI	R31,(totalExecutionTime) >> 8
	LDD	R16,Z+6
	INC	R16
	STD	Z+6,R16
	CPI	R16,8
	BRCC	??Kernel_Run_3
	MOV	R18,R16
	LDI	R19,0
	LDI	R16,13
	LDI	R17,0
	MUL	R17,R18
	MOV	R17,R0
	MUL	R16,R19
	ADD	R17,R0
	MUL	R16,R18
	MOV	R16,R0
	ADD	R17,R1
	MOVW	R31 : R30,R17 : R16
	SUBI	R30,LOW((-(taskQueue) & 0xFFFF))
	SBCI	R31,(-(taskQueue) & 0xFFFF) >> 8
	LD	R18,Z
	LDD	R19,Z+1
	CPI	R18,0
	SBCI	R19,0
	BRNE	??Kernel_Run_4
??Kernel_Run_3:
	LDI	R16,0
	LDI	R30,LOW(totalExecutionTime)
	LDI	R31,(totalExecutionTime) >> 8
	STD	Z+6,R16
??Kernel_Run_4:
	LDI	R30,LOW(taskQueue)
	LDI	R31,(taskQueue) >> 8
	ADIW	R27 : R26,6
	LD	R18,X
	SBIW	R27 : R26,6
	LDI	R19,0
	LDI	R16,13
	LDI	R17,0
	MUL	R17,R18
	MOV	R17,R0
	MUL	R16,R19
	ADD	R17,R0
	MUL	R16,R18
	ADD	R17,R1
	ADD	R30,R0
	ADC	R31,R17
	LDD	R16,Z+2
	TST	R16
	BRNE	??Kernel_Run_0
	LDD	R16,Z+7
	LDD	R17,Z+8
	OR	R16,R17
	BRNE	??Kernel_Run_0
	LDD	R16,Z+9
	LDD	R17,Z+10
	OR	R16,R17
	BRNE	??Kernel_Run_0
	LDD	R16,Z+11
	LDD	R17,Z+12
	OR	R16,R17
	BREQ	??Kernel_Run_5
	RJMP	??Kernel_Run_0
??Kernel_Run_5:
	LDI	R17,0
	MOVW	R31 : R30,R27 : R26
	STD	Z+4,R19
	STD	Z+5,R19
	IN	R16,0x32
	STD	Z+7,R16
	SEI
	LDD	R18,Z+6
	LDI	R16,13
	MUL	R17,R18
	MOV	R17,R0
	MUL	R16,R19
	ADD	R17,R0
	MUL	R16,R18
	MOV	R16,R0
	ADD	R17,R1
	MOVW	R31 : R30,R17 : R16
	SUBI	R30,LOW((-(taskQueue) & 0xFFFF))
	SBCI	R31,(-(taskQueue) & 0xFFFF) >> 8
	LD	R16,Z
	LDD	R17,Z+1
	MOVW	R31 : R30,R17 : R16
	ICALL
	CLI
	MOVW	R31 : R30,R27 : R26
	LDD	R18,Z+4
	LDD	R19,Z+5
	IN	R16,0x3C
	LDI	R17,0
	MUL	R17,R18
	MOV	R17,R0
	MUL	R16,R19
	ADD	R17,R0
	MUL	R16,R18
	ADD	R17,R1
	STD	Z+4,R0
	STD	Z+5,R17
	LDD	R16,Z+7
	IN	R17,0x32
	CP	R16,R17
	BRCC	??Kernel_Run_6
	RJMP	??Kernel_Run_1
??Kernel_Run_6:
	IN	R16,0x3C
	LDI	R17,0
	SUBI	R16,255
	SBCI	R17,255
	LDD	R18,Z+7
	LDI	R19,0
	SUB	R16,R18
	SBCI	R17,0
	IN	R18,0x32
	ADD	R18,R16
	ADC	R19,R17
	RJMP	??Kernel_Run_2
;   104 
;   105 #if TASKER_DEBUG_LEVEL > 1
;   106 		if(debugTimer == 0)
;   107 		{
;   108 			debugTimer=TASKER_DEBUG_RATE;
;   109 
;   110 			Kernel_DebuggerEvent(DEBUG_EVENT_TASKINFO, null, DEBUG_STATUS_OK, taskQueue[debugIndex].executionTime);
;   111 			debugIndex++;			
;   112 			if(taskQueue[debugIndex].theTask == null || debugIndex >= MAX_NUMBER_OF_TASKS)
;   113 				debugIndex=0;
;   114 		}
;   115 #endif
;   116 
;   117   }
;   118 }
;   119 
;   120 
;   121 /***************************************************************************************************************************
;   122 	
;   123 ***************************************************************************************************************************/

        RSEG CODE:CODE:NOROOT(1)
;   124 void SystemTimer(void)
;   125 {
;   126 unsigned char index;
;   127 
;   128 	// Tick all active task timers
;   129 	for(index=0;index<MAX_NUMBER_OF_TASKS;index++)				// For all task
; __nearfunc void SystemTimer();
SystemTimer:
	LDI	R30,LOW((taskQueue + 7))
	LDI	R31,(taskQueue + 7) >> 8
	LDI	R16,8
;   130 	{
;   131 		if(taskQueue[index].timer > 0)													// check if timer is active
??SystemTimer_0:
	LD	R18,Z
	LDD	R19,Z+1
	OR	R18,R19
	BREQ	??SystemTimer_1
;   132 		{
;   133 			taskQueue[index].timer--;
	LD	R18,Z
	LDD	R19,Z+1
	SUBI	R18,1
	SBCI	R19,0
	ST	Z,R18
	STD	Z+1,R19
??SystemTimer_1:
	ADIW	R31 : R30,13
	DEC	R16
	BRNE	??SystemTimer_0
;   134 		}
;   135 	}
;   136 	
;   137 	executionTimer++;
	LDI	R30,LOW(totalExecutionTime)
	LDI	R31,(totalExecutionTime) >> 8
	LDD	R16,Z+4
	LDD	R17,Z+5
	SUBI	R16,255
	SBCI	R17,255
	STD	Z+4,R16
	STD	Z+5,R17
;   138 	totalExecutionTime++;
	LD	R16,Z
	LDD	R17,Z+1
	LDD	R18,Z+2
	LDD	R19,Z+3
	SUBI	R16,255
	SBCI	R17,255
	SBCI	R18,255
	SBCI	R19,255
	ST	Z,R16
	STD	Z+1,R17
	STD	Z+2,R18
	STD	Z+3,R19
;   139 	
;   140 #if TASKER_DEBUG_LEVEL > 1
;   141 	if(debugTimer > 0)
;   142 		debugTimer--;
;   143 #endif
;   144 }
	RET
;   145 
;   146 
;   147 /***************************************************************************************************************************
;   148 	Returns the specfied tasks index in the task queue. If the task is not in the queue -1 is returned.
;   149 ***************************************************************************************************************************/

        RSEG CODE:CODE:NOROOT(1)
;   150 signed char TaskToIndex(task t)
;   151 {
;   152 unsigned char index;
;   153 
;   154 	for(index=0;index<MAX_NUMBER_OF_TASKS;index++)
; __nearfunc signed char TaskToIndex(task);
TaskToIndex:
	LDI	R18,0
;   155 	{
;   156 		if(taskQueue[index].theTask==t)
??TaskToIndex_0:
	LDI	R19,0
	LDI	R20,13
	LDI	R21,0
	MUL	R21,R18
	MOV	R21,R0
	MUL	R20,R19
	ADD	R21,R0
	MUL	R20,R18
	MOV	R20,R0
	ADD	R21,R1
	MOVW	R31 : R30,R21 : R20
	SUBI	R30,LOW((-(taskQueue) & 0xFFFF))
	SBCI	R31,(-(taskQueue) & 0xFFFF) >> 8
	LD	R20,Z
	LDD	R21,Z+1
	CP	R20,R16
	CPC	R21,R17
	BRNE	??TaskToIndex_1
;   157 			return index;
	MOV	R16,R18
	RET
??TaskToIndex_1:
	INC	R18
	CPI	R18,8
	BRCS	??TaskToIndex_0
;   158 	}
;   159 
;   160 	return -1;
	LDI	R16,255
	RET
;   161 }

        ASEGN ABSOLUTE:DATA:NOROOT,01cH
__?EECR:

        ASEGN ABSOLUTE:DATA:NOROOT,01dH
__?EEDR:

        ASEGN ABSOLUTE:DATA:NOROOT,01eH
__?EEARL:

        ASEGN ABSOLUTE:DATA:NOROOT,01fH
__?EEARH:

        RSEG INITTAB:CODE:NOROOT(0)
`?<Segment init: NEAR_Z>`:
	DW	SFE(NEAR_Z) - SFB(NEAR_Z)
	DW	SFB(NEAR_Z)
	DW	0
	REQUIRE ?need_segment_init

        RSEG NEAR_ID:CODE:NOROOT(0)
`?<Initializer for totalExecutionTime>`:
	DB 0, 0, 0, 0
`?<Initializer for executionTimer>`:
	DB 0, 0
`?<Initializer for currentTaskIndex>`:
	DB 255
`?<Initializer for tcnt>`:
	DB 0

        RSEG INITTAB:CODE:NOROOT(0)
`?<Segment init: NEAR_I>`:
	DW	SFE(NEAR_I) - SFB(NEAR_I)
	DW	SFB(NEAR_I)
	DW	SFB(NEAR_ID)
	REQUIRE ?need_segment_init

        END
; 
;      2 bytes in segment ABSOLUTE
;    540 bytes in segment CODE
;     12 bytes in segment INITTAB
;      8 bytes in segment NEAR_I
;      8 bytes in segment NEAR_ID
;    104 bytes in segment NEAR_Z
; 
;    548 bytes of CODE memory (+ 12 bytes shared)
;    112 bytes of DATA memory (+ 2 bytes shared)
;
;Errors: none
;Warnings: none
