##############################################################################
#                                                                            #
# IAR Atmel AVR C/EC++ Compiler V2.28A/WIN, Evaluation Version21/Dec/2007  21:30:35 #
# Copyright 1996-2002 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Source file  =  f:\Projects\[Drivers]\C\MROS\Kernel\MemoryManagementLin #
#                    kedList.c                                               #
#    Command line =  --cpu=m32 -ms -o f:\Projects\[Drivers]\C\MROS\TestApps\ #
#                    KernelTester\Release\Obj\ -I                            #
#                    C:\PROGRA~1\IARSYS~1\EW23EV~1\avr\SRC\CLIB\INC\ -I      #
#                    f:\Projects\[Drivers]\C\MROS\TestApps\KernelTester\ -I  #
#                    f:\Projects\[Drivers]\C\MROS\ -lC                       #
#                    f:\Projects\[Drivers]\C\MROS\TestApps\KernelTester\Rele #
#                    ase\List\ -lA f:\Projects\[Drivers]\C\MROS\TestApps\Ker #
#                    nelTester\Release\List\ -e --initializers_in_flash -s9  #
#                    -DENABLE_BIT_DEFINITIONS f:\Projects\[Drivers]\C\MROS\K #
#                    ernel\MemoryManagementLinkedList.c                      #
#    List file    =  f:\Projects\[Drivers]\C\MROS\TestApps\KernelTester\Rele #
#                    ase\List\MemoryManagementLinkedList.lst                 #
#    Object file  =  f:\Projects\[Drivers]\C\MROS\TestApps\KernelTester\Rele #
#                    ase\Obj\MemoryManagementLinkedList.r90                  #
#                                                                            #
#                                                                            #
##############################################################################

      1          #include <Globals.h>
      2          #include <Config.h>
      3          #include "MemoryManagementLinkedList.h"
      4          #include "Kernel.h"
      5          #include "KernelInternals.h"
      6          #include <Peripherals/UART.h>
      7          
      8          
      9          typedef struct
     10          {
     11          	bool free;
     12          	unsigned short size;
     13          	void* next;
     14          } block;
     15          
     16          

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
     17          static unsigned char heap[HEAP_SIZE];
   \   static unsigned char __near heap[1000];
   \                     heap:
   \   00000000                              DS 1000
     18          
     19          
     20          static void JoinFreeAdjacentBlocks();
     21          
     22          

   \                                 In segment NEAR_F, align 1, keep-with-next
     23          string txtHeapStart[]="Start of heap: ";
   \   char const __flash txtHeapStart[16];
   \                     txtHeapStart:
   \   00000000   745372612074               DB "Start of heap: "
   \            666F68206165
   \            3A700020    
     24          
     25          

   \                                 In segment CODE, align 2, keep-with-next
     26          void HeapInit()
     27          {
   \   __nearfunc void HeapInit();
   \                     HeapInit:
   \   00000000   93BA                       ST      -Y,R27
   \   00000002   93AA                       ST      -Y,R26
     28          block* b = (block*)heap;
     29          
     30          	b->free = true;
   \   00000004   ....                       LDI     R26,LOW(heap)
   \   00000006   ....                       LDI     R27,(heap) >> 8
   \   00000008   E001                       LDI     R16,1
   \   0000000A   930C                       ST      X,R16
     31          	b->size = HEAP_SIZE - sizeof(block);
   \   0000000C   EE03                       LDI     R16,227
   \   0000000E   E013                       LDI     R17,3
   \   00000010   9611                       ADIW    R27 : R26,1
   \   00000012   930D                       ST      X+,R16
   \   00000014   931C                       ST      X,R17
   \   00000016   9712                       SBIW    R27 : R26,2
     32          	b->next = null;
   \   00000018   E000                       LDI     R16,0
   \   0000001A   9613                       ADIW    R27 : R26,3
   \   0000001C   930D                       ST      X+,R16
   \   0000001E   930C                       ST      X,R16
   \   00000020   9714                       SBIW    R27 : R26,4
     33          	
     34          	UART_WriteString_P(txtHeapStart);
   \   00000022   ....                       LDI     R16,LOW(txtHeapStart)
   \   00000024   ....                       LDI     R17,(txtHeapStart) >> 8
   \   00000026   ........                   CALL    UART_WriteString_P
     35          	UART_WritePointer(heap);
   \   0000002A   018D                       MOVW    R17 : R16,R27 : R26
   \   0000002C   ........                   CALL    UART_WritePointer
     36          }
   \   00000030   91A9                       LD      R26,Y+
   \   00000032   91B9                       LD      R27,Y+
   \   00000034   9508                       RET
     37          
     38          

   \                                 In segment CODE, align 2, keep-with-next
     39          void* Allocate(unsigned short size)
     40          {
   \   __nearfunc void *Allocate(unsigned short);
   \                     Allocate:
   \   00000000   2E1B                       MOV     R1,R27
   \   00000002   2E0A                       MOV     R0,R26
   \   00000004   2F79                       MOV     R23,R25
   \   00000006   2F68                       MOV     R22,R24
   \   00000008   0198                       MOVW    R19 : R18,R17 : R16
     41          block* b = (block*)heap;
   \   0000000A   ....                       LDI     R30,LOW(heap)
   \   0000000C   ....                       LDI     R31,(heap) >> 8
   \   0000000E   C001                       RJMP    ??Allocate_0
     42          block* split;
     43          
     44          	while((b->free != true || b->size < size) && b->next != null)
     45          	{
     46          		b = (block*)b->next;
   \                     ??Allocate_1:
   \   00000010   01F8                       MOVW    R31 : R30,R17 : R16
   \                     ??Allocate_0:
   \   00000012   8100                       LD      R16,Z
   \   00000014   3001                       CPI     R16,1
   \   00000016   F429                       BRNE    ??Allocate_2
   \   00000018   8101                       LDD     R16,Z+1
   \   0000001A   8112                       LDD     R17,Z+2
   \   0000001C   1702                       CP      R16,R18
   \   0000001E   0713                       CPC     R17,R19
   \   00000020   F428                       BRCC    ??Allocate_3
   \                     ??Allocate_2:
   \   00000022   8103                       LDD     R16,Z+3
   \   00000024   8114                       LDD     R17,Z+4
   \   00000026   2F40                       MOV     R20,R16
   \   00000028   2B41                       OR      R20,R17
   \   0000002A   F791                       BRNE    ??Allocate_1
     47          	}
     48          	
     49          	if(b->free != true || b->size < size)																									// Found a valid block?
   \                     ??Allocate_3:
   \   0000002C   8100                       LD      R16,Z
   \   0000002E   3001                       CPI     R16,1
   \   00000030   F429                       BRNE    ??Allocate_4
   \   00000032   8181                       LDD     R24,Z+1
   \   00000034   8192                       LDD     R25,Z+2
   \   00000036   1782                       CP      R24,R18
   \   00000038   0793                       CPC     R25,R19
   \   0000003A   F418                       BRCC    ??Allocate_5
     50          	{
     51          		return null;																																					// No
   \                     ??Allocate_4:
   \   0000003C   E000                       LDI     R16,0
   \   0000003E   E010                       LDI     R17,0
   \   00000040   C024                       RJMP    ??Allocate_6
     52          	}
     53          	
     54          	if(b->size > (size + sizeof(block)))																									// Split block, return first part and mark last part as free
   \                     ??Allocate_5:
   \   00000042   018F                       MOVW    R17 : R16,R31 : R30
   \   00000044   5F0B                       SUBI    R16,251
   \   00000046   4F1F                       SBCI    R17,255
   \   00000048   01D9                       MOVW    R27 : R26,R19 : R18
   \   0000004A   9615                       ADIW    R27 : R26,5
   \   0000004C   17A8                       CP      R26,R24
   \   0000004E   07B9                       CPC     R27,R25
   \   00000050   F4D0                       BRCC    ??Allocate_7
     55          	{
     56          		split = (block*)((unsigned char*)b + sizeof(block) + size);
   \   00000052   01DF                       MOVW    R27 : R26,R31 : R30
   \   00000054   9615                       ADIW    R27 : R26,5
   \   00000056   0FA2                       ADD     R26,R18
   \   00000058   1FB3                       ADC     R27,R19
     57          		split->free = true;
   \   0000005A   E041                       LDI     R20,1
   \   0000005C   934C                       ST      X,R20
     58          		split->size = b->size - size - sizeof(block);
   \   0000005E   1B82                       SUB     R24,R18
   \   00000060   0B93                       SBC     R25,R19
   \   00000062   9705                       SBIW    R25 : R24,5
   \   00000064   9611                       ADIW    R27 : R26,1
   \   00000066   938D                       ST      X+,R24
   \   00000068   939C                       ST      X,R25
   \   0000006A   9712                       SBIW    R27 : R26,2
     59          		split->next = b->next;
   \   0000006C   8143                       LDD     R20,Z+3
   \   0000006E   8154                       LDD     R21,Z+4
   \   00000070   9613                       ADIW    R27 : R26,3
   \   00000072   934D                       ST      X+,R20
   \   00000074   935C                       ST      X,R21
   \   00000076   9714                       SBIW    R27 : R26,4
     60          		
     61          		b->free = false;
   \   00000078   E040                       LDI     R20,0
   \   0000007A   8340                       ST      Z,R20
     62          		b->size = size;
   \   0000007C   8321                       STD     Z+1,R18
   \   0000007E   8332                       STD     Z+2,R19
     63          		b->next = split;
   \   00000080   83A3                       STD     Z+3,R26
   \   00000082   83B4                       STD     Z+4,R27
     64          		
     65          		return (void*)((unsigned short)b + sizeof(block));
   \   00000084   C002                       RJMP    ??Allocate_6
     66          	}
     67          	else																																									// Block is too small to split - return all
     68          	{
     69          		b->free = false;
   \                     ??Allocate_7:
   \   00000086   E020                       LDI     R18,0
   \   00000088   8320                       ST      Z,R18
     70          		return (void*)((unsigned short)b + sizeof(block));
   \                     ??Allocate_6:
   \   0000008A   2F86                       MOV     R24,R22
   \   0000008C   2F97                       MOV     R25,R23
   \   0000008E   2DA0                       MOV     R26,R0
   \   00000090   2DB1                       MOV     R27,R1
   \   00000092   9508                       RET
     71          	}
     72          }
     73          
     74          

   \                                 In segment CODE, align 2, keep-with-next
     75          void Deallocate(void* pointer)
     76          {
   \   __nearfunc void Deallocate(void *);
   \                     Deallocate:
   \   00000000   93BA                       ST      -Y,R27
   \   00000002   93AA                       ST      -Y,R26
     77          block* b = (block*)heap;
   \   00000004   ....                       LDI     R26,LOW(heap)
   \   00000006   ....                       LDI     R27,(heap) >> 8
     78          block* p = (block*)((unsigned short)pointer - sizeof(block));
   \   00000008   5005                       SUBI    R16,5
   \   0000000A   4010                       SBCI    R17,0
   \   0000000C   C007                       RJMP    ??Deallocate_0
   \                     ??Deallocate_1:
   \   0000000E   9613                       ADIW    R27 : R26,3
   \   00000010   912D                       LD      R18,X+
   \   00000012   913C                       LD      R19,X
   \   00000014   2F42                       MOV     R20,R18
   \   00000016   2B43                       OR      R20,R19
   \   00000018   F161                       BREQ    ??Deallocate_2
     79          	
     80          	while(b != p && b->next != null)
     81          	{
     82          		b = (block*)b->next;
   \   0000001A   01D9                       MOVW    R27 : R26,R19 : R18
   \                     ??Deallocate_0:
   \   0000001C   17A0                       CP      R26,R16
   \   0000001E   07B1                       CPC     R27,R17
   \   00000020   F7B1                       BRNE    ??Deallocate_1
     83          	}
     84          	
     85          	if(b != p)
     86          	{
     87          		return;																																								// Invalid pointer
     88          	}
     89          
     90          	UART_WriteString("FREE\r\n");
   \   00000022   ....                       LDI     R16,LOW(`?<Constant "FREE\\r\\n">`)
   \   00000024   ....                       LDI     R17,(`?<Constant "FREE\\r\\n">`) >> 8
   \   00000026   ........                   CALL    UART_WriteString
     91          	
     92          	b->free = true;
   \   0000002A   E001                       LDI     R16,1
   \   0000002C   930C                       ST      X,R16
     93          
     94          	JoinFreeAdjacentBlocks();
   \   0000002E   ....                       LDI     R30,LOW(heap)
   \   00000030   ....                       LDI     R31,(heap) >> 8
   \   00000032   C011                       RJMP    ??Deallocate_3
   \                     ??Deallocate_4:
   \   00000034   9611                       ADIW    R27 : R26,1
   \   00000036   910D                       LD      R16,X+
   \   00000038   911C                       LD      R17,X
   \   0000003A   9712                       SBIW    R27 : R26,2
   \   0000003C   5F0B                       SUBI    R16,251
   \   0000003E   4F1F                       SBCI    R17,255
   \   00000040   8121                       LDD     R18,Z+1
   \   00000042   8132                       LDD     R19,Z+2
   \   00000044   0F20                       ADD     R18,R16
   \   00000046   1F31                       ADC     R19,R17
   \   00000048   8321                       STD     Z+1,R18
   \   0000004A   8332                       STD     Z+2,R19
   \   0000004C   9613                       ADIW    R27 : R26,3
   \   0000004E   910D                       LD      R16,X+
   \   00000050   911C                       LD      R17,X
   \   00000052   8303                       STD     Z+3,R16
   \   00000054   8314                       STD     Z+4,R17
   \                     ??Deallocate_3:
   \   00000056   8103                       LDD     R16,Z+3
   \   00000058   8114                       LDD     R17,Z+4
   \   0000005A   2F20                       MOV     R18,R16
   \   0000005C   2B21                       OR      R18,R17
   \   0000005E   F049                       BREQ    ??Deallocate_2
   \   00000060   01D8                       MOVW    R27 : R26,R17 : R16
   \   00000062   8120                       LD      R18,Z
   \   00000064   3021                       CPI     R18,1
   \   00000066   F419                       BRNE    ??Deallocate_5
   \   00000068   912C                       LD      R18,X
   \   0000006A   3021                       CPI     R18,1
   \   0000006C   F319                       BREQ    ??Deallocate_4
   \                     ??Deallocate_5:
   \   0000006E   01F8                       MOVW    R31 : R30,R17 : R16
   \   00000070   CFF2                       RJMP    ??Deallocate_3
   \                     ??Deallocate_2:
   \   00000072   91A9                       LD      R26,Y+
   \   00000074   91B9                       LD      R27,Y+
   \   00000076   9508                       RET
     95          }

   \                                 In segment NEAR_I, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_I>`
   \   char __near <Constant "FREE\r\n">[7];
   \                     `?<Constant "FREE\\r\\n">`:
   \   00000000                              DS 7
   \   00000007                              REQUIRE `?<Initializer for <Constant "FREE\\r\\n">>`

   \                                 In segment NEAR_ID, align 1, keep-with-next
   \                     `?<Initializer for <Constant "FREE\\r\\n">>`:
   \   00000000   524645450A0D               DB "FREE\015\012"
   \            00          
     96          
     97          
     98          static void JoinFreeAdjacentBlocks()
     99          {
    100          block* b = (block*)heap;
    101          block* next;
    102          
    103          	while(b->next != null)
    104          	{
    105          		next = (block*)b->next;
    106          		if(b->free == true && next->free == true)
    107          		{
    108          			b->size += next->size + sizeof(block);
    109          			b->next = next->next;
    110          		}
    111          		else
    112          		{
    113          			b = (block*)b->next;
    114          		}
    115          	}
    116          }

   Maximum stack usage in bytes:

     Function                 CSTACK  RSTACK
     --------                 ------  ------
     Allocate                     0       0 
     Deallocate                   2       2 
       -> UART_WriteString        2       2 
     HeapInit                     2       2 
       -> UART_WriteString_P      2       2 
       -> UART_WritePointer       2       2 

 
    322 bytes in segment CODE
     12 bytes in segment INITTAB
     16 bytes in segment NEAR_F
      7 bytes in segment NEAR_I
      7 bytes in segment NEAR_ID
   1000 bytes in segment NEAR_Z
 
    345 bytes of CODE memory (+ 12 bytes shared)
   1007 bytes of DATA memory

Errors: none
Warnings: none
