##############################################################################
#                                                                            #
#                                                      09/Mar/2008  16:00:45 #
# IAR Atmel AVR C/C++ Compiler V4.21A/W32, Evaluation Version                #
# Copyright 1996-2006 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Source file  =  f:\Projects\[Drivers]\C\MROS\Kernel\MemoryManagement.c  #
#    Command line =  --string_literals_in_flash                              #
#                    f:\Projects\[Drivers]\C\MROS\Kernel\MemoryManagement.c  #
#                    --cpu=m32 -ms -o f:\Projects\[Drivers]\C\MROS\TestApps\ #
#                    CommanderTester\Release\Obj\ -D NDEBUG -lC              #
#                    f:\Projects\[Drivers]\C\MROS\TestApps\CommanderTester\R #
#                    elease\List\ -lA f:\Projects\[Drivers]\C\MROS\TestApps\ #
#                    CommanderTester\Release\List\ --initializers_in_flash   #
#                    -s9 -DENABLE_BIT_DEFINITIONS -e -I                      #
#                    f:\Projects\[Drivers]\C\mros\TestApps\CommanderTester\  #
#                    -I f:\Projects\[Drivers]\C\mros\ -I "C:\Program         #
#                    Files\IAR Systems\Embedded Workbench 4.0                #
#                    Evaluation\avr\INC\" -I "C:\Program Files\IAR           #
#                    Systems\Embedded Workbench 4.0                          #
#                    Evaluation\avr\INC\CLIB\" --eeprom_size 1024            #
#    List file    =  f:\Projects\[Drivers]\C\MROS\TestApps\CommanderTester\R #
#                    elease\List\MemoryManagement.lst                        #
#    Object file  =  f:\Projects\[Drivers]\C\MROS\TestApps\CommanderTester\R #
#                    elease\Obj\MemoryManagement.r90                         #
#                                                                            #
#                                                                            #
##############################################################################

f:\Projects\[Drivers]\C\MROS\Kernel\MemoryManagement.c
      1          #include <Globals.h>
      2          #include <Config.h>
      3          #include "MemoryManagement.h"
      4          #include "Kernel.h"
      5          #include "KernelInternals.h"
      6          
      7          
      8          typedef struct
      9          {
     10          	bool free;
     11          	unsigned short size;
     12          	void* next;
     13          } block;
     14          
     15          
     16          static unsigned char heap[HEAP_SIZE];
                                           ^
Error[Pe020]: identifier "HEAP_SIZE" is undefined
     17          
     18          
     19          static void JoinFreeAdjacentBlocks();
     20          
     21          
     22          void Kernel_InitHeap()
     23          {
     24          block* b = (block*)heap;
     25          
     26          	b->free = true;
     27          	b->size = HEAP_SIZE - sizeof(block);
     28          	b->next = null;
     29          }
     30          
     31          
     32          void* Kernel_Allocate(unsigned short size)
     33          {
     34          block* b = (block*)heap;
     35          block* split;
     36          
     37          	while((b->free != true || b->size < size) && b->next != null)
     38          	{
     39          		b = (block*)b->next;
     40          	}
     41          	
     42          	if(b->free != true || b->size < size)																									// Found a valid block?
     43          	{
     44          		return null;																																					// No
     45          	}
     46          	
     47          	if(b->size > (size + sizeof(block)))																									// Split block, return first part and mark last part as free
     48          	{
     49          		split = (block*)((unsigned char*)b + sizeof(block) + size);
     50          		split->free = true;
     51          		split->size = b->size - size - sizeof(block);
     52          		split->next = b->next;
     53          		
     54          		b->free = false;
     55          		b->size = size;
     56          		b->next = split;
     57          		
     58          		return (void*)((unsigned short)b + sizeof(block));
     59          	}
     60          	else																																									// Block is too small to split - return all
     61          	{
     62          		b->free = false;
     63          		return (void*)((unsigned short)b + sizeof(block));
     64          	}
     65          }
     66          
     67          
     68          void Kernel_Deallocate(void* pointer)
     69          {
     70          block* b = (block*)heap;
     71          block* p = (block*)((unsigned short)pointer - sizeof(block));
     72          	
     73          	while(b != p && b->next != null)
     74          	{
     75          		b = (block*)b->next;
     76          	}
     77          	
     78          	if(b != p)
     79          	{
     80          		return;																																								// Invalid pointer
     81          	}
     82          	
     83          	b->free = true;
     84          
     85          	JoinFreeAdjacentBlocks();
     86          }
     87          
     88          
     89          static void JoinFreeAdjacentBlocks()
     90          {
     91          block* b = (block*)heap;
     92          block* next;
     93          
     94          	while(b->next != null)
     95          	{
     96          		next = (block*)b->next;
     97          		if(b->free == true && next->free == true)
     98          		{
     99          			b->size += next->size + sizeof(block);
    100          			b->next = next->next;
    101          		}
    102          		else
    103          		{
    104          			b = (block*)b->next;
    105          		}
    106          	}
    107          }

Errors: 1
Warnings: none
