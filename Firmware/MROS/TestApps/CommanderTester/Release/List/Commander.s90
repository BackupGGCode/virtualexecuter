//////////////////////////////////////////////////////////////////////////////
//                                                                           /
//                                                     09/Mar/2008  16:57:08 /
// IAR Atmel AVR C/C++ Compiler V4.21A/W32, Evaluation Version               /
// Copyright 1996-2006 IAR Systems. All rights reserved.                     /
//                                                                           /
//    Source file  =  f:\Projects\[Drivers]\C\MROS\Commander\Commander.c     /
//    Command line =  --string_literals_in_flash                             /
//                    f:\Projects\[Drivers]\C\MROS\Commander\Commander.c     /
//                    --cpu=m32 -ms -o f:\Projects\[Drivers]\C\MROS\TestApps /
//                    \CommanderTester\Release\Obj\ -D NDEBUG -lC            /
//                    f:\Projects\[Drivers]\C\MROS\TestApps\CommanderTester\ /
//                    Release\List\ -lA f:\Projects\[Drivers]\C\MROS\TestApp /
//                    s\CommanderTester\Release\List\                        /
//                    --initializers_in_flash -s9 -DENABLE_BIT_DEFINITIONS   /
//                    -e -I f:\Projects\[Drivers]\C\mros\TestApps\CommanderT /
//                    ester\ -I f:\Projects\[Drivers]\C\mros\ -I             /
//                    "C:\Program Files\IAR Systems\Embedded Workbench 4.0   /
//                    Evaluation\avr\INC\" -I "C:\Program Files\IAR          /
//                    Systems\Embedded Workbench 4.0                         /
//                    Evaluation\avr\INC\CLIB\" --eeprom_size 1024           /
//    List file    =  f:\Projects\[Drivers]\C\MROS\TestApps\CommanderTester\ /
//                    Release\List\Commander.s90                             /
//                                                                           /
//                                                                           /
//////////////////////////////////////////////////////////////////////////////

        NAME Commander

        RTMODEL "__64bit_doubles", "disabled"
        RTMODEL "__cpu", "3"
        RTMODEL "__cpu_name", "ATmega32"
        RTMODEL "__enhanced_core", "enabled"
        RTMODEL "__has_elpm", "false"
        RTMODEL "__memory_model", "2"
        RTMODEL "__rt_version", "3"

        RSEG CSTACK:DATA:NOROOT(0)
        RSEG RSTACK:DATA:NOROOT(0)

        EXTERN ?Register_R4_is_cg_reg
        EXTERN ?Register_R5_is_cg_reg
        EXTERN ?need_segment_init

        PUBWEAK `?<Segment init: NEAR_I>`
        PUBWEAK `?<Segment init: NEAR_Z>`
        PUBLIC Commander_Run
        FUNCTION Commander_Run,061201H
        LOCFRAME CSTACK, 6, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBWEAK _A_PORTB
        PUBWEAK __?EEARH
        PUBWEAK __?EEARL
        PUBWEAK __?EECR
        PUBWEAK __?EEDR
        PUBLIC prompt
        
        CFI Names cfiNames0
        CFI StackFrame CFA_Y Y DATA
        CFI StackFrame CFA_SP SP DATA
        CFI VirtualResource ?RetPad:1, ?RetHigh:8, ?RetLow:8, ?Ret:17
        CFI Resource R0:8, R1:8, R2:8, R3:8, R4:8, R5:8, R6:8, R7:8, R8:8, R9:8
        CFI Resource R10:8, R11:8, R12:8, R13:8, R14:8, R15:8, R16:8, R17:8
        CFI Resource R18:8, R19:8, R20:8, R21:8, R22:8, R23:8, R24:8, R25:8
        CFI Resource R26:8, R27:8, R28:8, R29:8, R30:8, R31:8
        CFI Resource ?RetHighByteMask:8, SP:16, SPH:8, SPL:8, Y:16
        CFI ResourceParts ?Ret ?RetHigh, ?RetLow, ?RetPad
        CFI ResourceParts SP SPH, SPL
        CFI ResourceParts Y R29, R28
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 1
        CFI DataAlign 1
        CFI ReturnAddress ?Ret CODE
        CFI CFA_Y Y+0
        CFI CFA_SP SP+2
        CFI ?RetPad 0
        CFI ?RetHigh and(load(1, DATA, sub(CFA_SP, 1)), ?RetHighByteMask)
        CFI ?RetLow Frame(CFA_SP, 0)
        CFI ?Ret Concat
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 SameValue
        CFI R13 SameValue
        CFI R14 SameValue
        CFI R15 SameValue
        CFI R16 Undefined
        CFI R17 Undefined
        CFI R18 Undefined
        CFI R19 Undefined
        CFI R20 Undefined
        CFI R21 Undefined
        CFI R22 Undefined
        CFI R23 Undefined
        CFI R24 SameValue
        CFI R25 SameValue
        CFI R26 SameValue
        CFI R27 SameValue
        CFI R28 Undefined
        CFI R29 Undefined
        CFI R30 Undefined
        CFI R31 Undefined
        CFI ?RetHighByteMask SameValue
        CFI SPH Undefined
        CFI SPL Undefined
        CFI EndCommon cfiCommon0
        
        EXTERN UART_BytesReady
        FUNCTION UART_BytesReady,0202H
        EXTERN UART_ReadByte
        FUNCTION UART_ReadByte,0202H
        EXTERN UART_WriteByte
        FUNCTION UART_WriteByte,0202H
        EXTERN UART_WriteString_P
        FUNCTION UART_WriteString_P,0202H
        EXTERN StringCompare_PD
        FUNCTION StringCompare_PD,0202H
        EXTERN UART_WriteString
        FUNCTION UART_WriteString,0202H
        EXTERN commands

// f:\Projects\[Drivers]\C\MROS\Commander\Commander.c
//    1 #include <Globals.h>

        ASEGN ABSOLUTE:DATA:NOROOT,038H
// union <unnamed> volatile __io _A_PORTB
_A_PORTB:
        DS 1
//    2 #include "Config.h"
//    3 #include <Kernel/Kernel.h>
//    4 #include "Commander.h"
//    5 #include <Peripherals/UART.h>
//    6 #include <strings.h>
//    7 
//    8 
//    9 char prompt[COMMANDER_PROMPT_LENGTH] = ">";
//   10 
//   11 

        RSEG CODE:CODE:NOROOT(1)
//   12 void Commander_Run()
Commander_Run:
        CFI Block cfiBlock0 Using cfiCommon0
        CFI Function Commander_Run
//   13 {
        FUNCALL Commander_Run, UART_BytesReady
        LOCFRAME CSTACK, 6, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Commander_Run, UART_ReadByte
        LOCFRAME CSTACK, 6, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Commander_Run, UART_WriteByte
        LOCFRAME CSTACK, 6, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Commander_Run, UART_WriteByte
        LOCFRAME CSTACK, 6, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Commander_Run, UART_WriteByte
        LOCFRAME CSTACK, 6, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Commander_Run, UART_WriteByte
        LOCFRAME CSTACK, 6, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Commander_Run, UART_WriteByte
        LOCFRAME CSTACK, 6, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Commander_Run, UART_WriteString_P
        LOCFRAME CSTACK, 6, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Commander_Run, StringCompare_PD
        LOCFRAME CSTACK, 6, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Commander_Run
        LOCFRAME CSTACK, 6, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Commander_Run, UART_WriteString_P
        LOCFRAME CSTACK, 6, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Commander_Run, UART_WriteString_P
        LOCFRAME CSTACK, 6, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Commander_Run, UART_WriteString
        LOCFRAME CSTACK, 6, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Commander_Run, UART_WriteByte
        LOCFRAME CSTACK, 6, STACK
        LOCFRAME RSTACK, 2, STACK
        ST      -Y, R5
        CFI R5 Frame(CFA_Y, -1)
        CFI CFA_Y Y+1
        ST      -Y, R4
        CFI R4 Frame(CFA_Y, -2)
        CFI CFA_Y Y+2
        ST      -Y, R27
        CFI R27 Frame(CFA_Y, -3)
        CFI CFA_Y Y+3
        ST      -Y, R26
        CFI R26 Frame(CFA_Y, -4)
        CFI CFA_Y Y+4
        ST      -Y, R25
        CFI R25 Frame(CFA_Y, -5)
        CFI CFA_Y Y+5
        ST      -Y, R24
        CFI R24 Frame(CFA_Y, -6)
        CFI CFA_Y Y+6
        REQUIRE ?Register_R4_is_cg_reg
        REQUIRE ?Register_R5_is_cg_reg
//   14 	static bool overflow = false;
//   15 	static unsigned char index = 0;
//   16 	static char buffer[COMMANDER_MAX_LINE_LENGTH+1];
//   17 	unsigned char data;
//   18 	unsigned char i;
//   19 	bool commandFound=false;
        LDI     R24, 0
//   20 	
//   21 	if(UART_BytesReady())
        CALL    UART_BytesReady
        TST     R16
        BRNE    $+2+2
        RJMP    ??Commander_Run_0
//   22 	{
//   23 		data = UART_ReadByte();
        CALL    UART_ReadByte
//   24 		
//   25 		if(data==0xff)		// This is where all the naughty keys go... TO IGNORE LAND!
        CPI     R16, 255
        BRNE    $+2+2
        RJMP    ??Commander_Run_0
//   26 		{
//   27 			return;
//   28 		}
//   29 		if(data==0x0d)
        CPI     R16, 13
        BRNE    ??Commander_Run_1
//   30 		{
//   31 			UART_WriteByte(0x0d);
        LDI     R16, 13
        CALL    UART_WriteByte
        RJMP    ??Commander_Run_0
//   32 		}
//   33 		else if(data == 8)
??Commander_Run_1:
        LDI     R26, LOW(??overflow)
        LDI     R27, (??overflow) >> 8
        MOVW    R31:R30, R27:R26
        LDD     R18, Z+1
        CPI     R16, 8
        BRNE    ??Commander_Run_2
//   34 		{
//   35 			if(index>0)
        TST     R18
        BRNE    $+2+2
        RJMP    ??Commander_Run_0
//   36 			{
//   37 				UART_WriteByte(8);
        LDI     R16, 8
        CALL    UART_WriteByte
//   38 				UART_WriteByte(' ');
        LDI     R16, 32
        CALL    UART_WriteByte
//   39 				UART_WriteByte(8);
        LDI     R16, 8
        CALL    UART_WriteByte
//   40 				index--;
        MOVW    R31:R30, R27:R26
        LDD     R16, Z+1
        DEC     R16
        STD     Z+1, R16
//   41 				buffer[index]=0;
        MOV     R18, R16
        LDI     R19, 0
        MOVW    R31:R30, R19:R18
        SUBI    R30, LOW((-(??buffer) & 0xFFFF))
        SBCI    R31, (-(??buffer) & 0xFFFF) >> 8
        ST      Z, R24
//   42 				overflow = false;
??Commander_Run_3:
        ST      X, R24
        RJMP    ??Commander_Run_0
//   43 			}
//   44 		}
//   45 		else if(data == 0x0a)
??Commander_Run_2:
        CPI     R16, 10
        BREQ    $+2+2
        RJMP    ??Commander_Run_4
//   46 		{
//   47 			PORTB&=~(1<<6);
        CBI     0x18, 0x06
//   48 			UART_WriteByte(0x0a);
        LDI     R16, 10
        CALL    UART_WriteByte
//   49 						
//   50 			if(overflow)
        LD      R16, X
        TST     R16
        BREQ    ??Commander_Run_5
//   51 			{
//   52 				UART_WriteString_P("Line too long\n");
        LDI     R16, LOW(`?<Constant "Line too long\\n">`)
        LDI     R17, (`?<Constant "Line too long\\n">`) >> 8
        CALL    UART_WriteString_P
//   53 				overflow=false;
        ST      X, R24
        RJMP    ??Commander_Run_6
//   54 			}
//   55 			else if(index > 0)
??Commander_Run_5:
        MOVW    R31:R30, R27:R26
        LDD     R18, Z+1
        TST     R18
        BREQ    ??Commander_Run_6
//   56 			{
//   57 				buffer[index++] = 0;
        LDI     R19, 0
        MOVW    R31:R30, R19:R18
        SUBI    R30, LOW((-(??buffer) & 0xFFFF))
        SBCI    R31, (-(??buffer) & 0xFFFF) >> 8
        ST      Z, R24
        MOVW    R31:R30, R27:R26
        LDD     R16, Z+1
        INC     R16
        STD     Z+1, R16
//   58 	
//   59 				for(i=0; i<COMMANDER_COMMAND_COUNT; i++)
        LDI     R16, LOW(commands)
        MOV     R4, R16
        LDI     R16, (commands) >> 8
        MOV     R5, R16
        LDI     R25, 5
//   60 				{
//   61 					if(StringCompare_PD(commands[i].name, buffer))
??Commander_Run_7:
        LDI     R18, LOW(??buffer)
        LDI     R19, (??buffer) >> 8
        MOVW    R31:R30, R5:R4
        LPM     R16, Z+
        LPM     R17, Z
        CALL    StringCompare_PD
        TST     R16
        BREQ    ??Commander_Run_8
//   62 					{
//   63 						commands[i].handler(buffer);
        LDI     R16, LOW(??buffer)
        LDI     R17, (??buffer) >> 8
        MOVW    R31:R30, R5:R4
        ADIW    R31:R30, 2
        LPM     R18, Z+
        LPM     R19, Z
        MOVW    R31:R30, R19:R18
        ICALL
//   64 						UART_WriteString_P("\n");
        LDI     R16, LOW((`?<Constant "Line too long\\n">` + 15))
        LDI     R17, HIGH((`?<Constant "Line too long\\n">` + 15))
        CALL    UART_WriteString_P
//   65 						commandFound=true;
        LDI     R24, 1
//   66 					}
//   67 				}
??Commander_Run_8:
        LDI     R16, 4
        ADD     R4, R16
        LDI     R16, 0
        ADC     R5, R16
        DEC     R25
        BRNE    ??Commander_Run_7
//   68 				
//   69 				if(commandFound==false)
        TST     R24
        BRNE    ??Commander_Run_6
//   70 				{
//   71 					UART_WriteString_P("Unknown command\n");
        LDI     R16, LOW((`?<Constant "Line too long\\n">` + 17))
        LDI     R17, HIGH((`?<Constant "Line too long\\n">` + 17))
        CALL    UART_WriteString_P
//   72 				}
//   73 			}
//   74 			
//   75 			index=0;
??Commander_Run_6:
        LDI     R16, 0
        MOVW    R31:R30, R27:R26
        STD     Z+1, R16
//   76 			
//   77 			UART_WriteString(prompt);
        ADIW    R27:R26, 2
        MOVW    R17:R16, R27:R26
        CALL    UART_WriteString
//   78 			PORTB|=(1<<6);
        SBI     0x18, 0x06
        RJMP    ??Commander_Run_0
//   79 		}
//   80 		else
//   81 		{
//   82 			if(index < COMMANDER_MAX_LINE_LENGTH)
??Commander_Run_4:
        CPI     R18, 50
        BRCC    ??Commander_Run_9
//   83 			{
//   84 				buffer[index++] = data;
        LDI     R19, 0
        MOVW    R31:R30, R19:R18
        SUBI    R30, LOW((-(??buffer) & 0xFFFF))
        SBCI    R31, (-(??buffer) & 0xFFFF) >> 8
        ST      Z, R16
        MOVW    R31:R30, R27:R26
        LDD     R17, Z+1
        INC     R17
        STD     Z+1, R17
//   85 				UART_WriteByte(data);
        CALL    UART_WriteByte
//   86 				overflow = false;
        RJMP    ??Commander_Run_3
//   87 			}
//   88 			else
//   89 			{
//   90 				overflow = true;
??Commander_Run_9:
        LDI     R16, 1
        ST      X, R16
??Commander_Run_0:
        LD      R24, Y+
        CFI R24 SameValue
        CFI CFA_Y Y+5
        LD      R25, Y+
        CFI R25 SameValue
        CFI CFA_Y Y+4
        LD      R26, Y+
        CFI R26 SameValue
        CFI CFA_Y Y+3
        LD      R27, Y+
        CFI R27 SameValue
        CFI CFA_Y Y+2
        LD      R4, Y+
        CFI R4 SameValue
        CFI CFA_Y Y+1
        LD      R5, Y+
        CFI R5 SameValue
        CFI CFA_Y Y+0
        RET
        CFI EndBlock cfiBlock0
//   91 			}
//   92 		}
//   93 	}
//   94 }

        RSEG NEAR_I:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_I>`
??overflow:
        DS 1
        REQUIRE `?<Initializer for overflow>`
        DS 1
        REQUIRE `?<Initializer for index>`
prompt:
        DS 4
        REQUIRE `?<Initializer for prompt>`

        RSEG NEAR_Z:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
??buffer:
        DS 51

        ASEGN ABSOLUTE:DATA:NOROOT,01cH
__?EECR:

        ASEGN ABSOLUTE:DATA:NOROOT,01dH
__?EEDR:

        ASEGN ABSOLUTE:DATA:NOROOT,01eH
__?EEARL:

        ASEGN ABSOLUTE:DATA:NOROOT,01fH
__?EEARH:

        RSEG NEAR_ID:CODE:NOROOT(0)
`?<Initializer for overflow>`:
        DB 0
`?<Initializer for index>`:
        DB 0
`?<Initializer for prompt>`:
        DB ">"
        DB 0, 0

        RSEG INITTAB:CODE:NOROOT(0)
`?<Segment init: NEAR_I>`:
        DW      SFE(NEAR_I) - SFB(NEAR_I)
        DW      SFB(NEAR_I)
        DW      SFB(NEAR_ID)
        REQUIRE ?need_segment_init

        RSEG INITTAB:CODE:NOROOT(0)
`?<Segment init: NEAR_Z>`:
        DW      SFE(NEAR_Z) - SFB(NEAR_Z)
        DW      SFB(NEAR_Z)
        DW      0
        REQUIRE ?need_segment_init

        RSEG NEAR_F:CODE:NOROOT(0)
`?<Constant "Line too long\\n">`:
        DB "Line too long\012"
        DB "\012"
        DB "Unknown command\012"

        END
// 
//   1 byte  in segment ABSOLUTE
// 306 bytes in segment CODE
//  12 bytes in segment INITTAB
//  34 bytes in segment NEAR_F
//   6 bytes in segment NEAR_I
//   6 bytes in segment NEAR_ID
//  51 bytes in segment NEAR_Z
// 
// 346 bytes of CODE memory (+ 12 bytes shared)
//  57 bytes of DATA memory (+  1 byte  shared)
//
//Errors: none
//Warnings: none
