//////////////////////////////////////////////////////////////////////////////
//                                                                           /
//                                                     09/Mar/2008  16:57:11 /
// IAR Atmel AVR C/C++ Compiler V4.21A/W32, Evaluation Version               /
// Copyright 1996-2006 IAR Systems. All rights reserved.                     /
//                                                                           /
//    Source file  =  f:\Projects\[Drivers]\C\MROS\Peripherals\UART.c        /
//    Command line =  --string_literals_in_flash                             /
//                    f:\Projects\[Drivers]\C\MROS\Peripherals\UART.c        /
//                    --cpu=m32 -ms -o f:\Projects\[Drivers]\C\MROS\TestApps /
//                    \CommanderTester\Release\Obj\ -D NDEBUG -lC            /
//                    f:\Projects\[Drivers]\C\MROS\TestApps\CommanderTester\ /
//                    Release\List\ -lA f:\Projects\[Drivers]\C\MROS\TestApp /
//                    s\CommanderTester\Release\List\                        /
//                    --initializers_in_flash -s9 -DENABLE_BIT_DEFINITIONS   /
//                    -e -I f:\Projects\[Drivers]\C\mros\TestApps\CommanderT /
//                    ester\ -I f:\Projects\[Drivers]\C\mros\ -I             /
//                    "C:\Program Files\IAR Systems\Embedded Workbench 4.0   /
//                    Evaluation\avr\INC\" -I "C:\Program Files\IAR          /
//                    Systems\Embedded Workbench 4.0                         /
//                    Evaluation\avr\INC\CLIB\" --eeprom_size 1024           /
//    List file    =  f:\Projects\[Drivers]\C\MROS\TestApps\CommanderTester\ /
//                    Release\List\UART.s90                                  /
//                                                                           /
//                                                                           /
//////////////////////////////////////////////////////////////////////////////

        NAME UART

        RTMODEL "__64bit_doubles", "disabled"
        RTMODEL "__cpu", "3"
        RTMODEL "__cpu_name", "ATmega32"
        RTMODEL "__enhanced_core", "enabled"
        RTMODEL "__has_elpm", "false"
        RTMODEL "__memory_model", "2"
        RTMODEL "__rt_version", "3"

        RSEG CSTACK:DATA:NOROOT(0)
        RSEG RSTACK:DATA:NOROOT(0)

        EXTERN ?UL_DIVMOD_L03

        PUBLIC UART_BytesReady
        FUNCTION UART_BytesReady,0203H
        LOCFRAME RSTACK, 2, STACK
        PUBLIC UART_Init
        FUNCTION UART_Init,0203H
        LOCFRAME RSTACK, 2, STACK
        PUBLIC UART_ReadByte
        FUNCTION UART_ReadByte,0203H
        LOCFRAME RSTACK, 2, STACK
        PUBLIC UART_ReadBytes
        FUNCTION UART_ReadBytes,021203H
        LOCFRAME CSTACK, 3, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC UART_SetBaudrate
        FUNCTION UART_SetBaudrate,0203H
        LOCFRAME RSTACK, 2, STACK
        PUBLIC UART_WriteByte
        FUNCTION UART_WriteByte,0203H
        LOCFRAME RSTACK, 2, STACK
        PUBLIC UART_WriteBytes
        FUNCTION UART_WriteBytes,0203H
        LOCFRAME RSTACK, 2, STACK
        PUBLIC UART_WritePointer
        FUNCTION UART_WritePointer,021203H
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC UART_WriteString
        FUNCTION UART_WriteString,0203H
        LOCFRAME RSTACK, 2, STACK
        PUBLIC UART_WriteString_P
        FUNCTION UART_WriteString_P,0203H
        LOCFRAME RSTACK, 2, STACK
        PUBLIC UART_WriteValueUnsigned
        FUNCTION UART_WriteValueUnsigned,0203H
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 4, STACK
        FUNCTION WriteHexDigit,0203H
        LOCFRAME RSTACK, 2, STACK
        PUBWEAK _A_UBRRH
        PUBWEAK _A_UBRRL
        PUBWEAK _A_UCSRA
        PUBWEAK _A_UCSRB
        PUBWEAK _A_UDR
        PUBWEAK __?EEARH
        PUBWEAK __?EEARL
        PUBWEAK __?EECR
        PUBWEAK __?EEDR
        PUBLIC getc
        FUNCTION getc,021203H
        LOCFRAME RSTACK, 2, STACK
        PUBLIC putc
        FUNCTION putc,0203H
        LOCFRAME RSTACK, 2, STACK
        PUBLIC putchar
        FUNCTION putchar,0203H
        LOCFRAME RSTACK, 2, STACK
        
        CFI Names cfiNames0
        CFI StackFrame CFA_Y Y DATA
        CFI StackFrame CFA_SP SP DATA
        CFI VirtualResource ?RetPad:1, ?RetHigh:8, ?RetLow:8, ?Ret:17
        CFI Resource R0:8, R1:8, R2:8, R3:8, R4:8, R5:8, R6:8, R7:8, R8:8, R9:8
        CFI Resource R10:8, R11:8, R12:8, R13:8, R14:8, R15:8, R16:8, R17:8
        CFI Resource R18:8, R19:8, R20:8, R21:8, R22:8, R23:8, R24:8, R25:8
        CFI Resource R26:8, R27:8, R28:8, R29:8, R30:8, R31:8
        CFI Resource ?RetHighByteMask:8, SP:16, SPH:8, SPL:8, Y:16
        CFI ResourceParts ?Ret ?RetHigh, ?RetLow, ?RetPad
        CFI ResourceParts SP SPH, SPL
        CFI ResourceParts Y R29, R28
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 1
        CFI DataAlign 1
        CFI ReturnAddress ?Ret CODE
        CFI CFA_Y Y+0
        CFI CFA_SP SP+2
        CFI ?RetPad 0
        CFI ?RetHigh and(load(1, DATA, sub(CFA_SP, 1)), ?RetHighByteMask)
        CFI ?RetLow Frame(CFA_SP, 0)
        CFI ?Ret Concat
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 SameValue
        CFI R13 SameValue
        CFI R14 SameValue
        CFI R15 SameValue
        CFI R16 Undefined
        CFI R17 Undefined
        CFI R18 Undefined
        CFI R19 Undefined
        CFI R20 Undefined
        CFI R21 Undefined
        CFI R22 Undefined
        CFI R23 Undefined
        CFI R24 SameValue
        CFI R25 SameValue
        CFI R26 SameValue
        CFI R27 SameValue
        CFI R28 Undefined
        CFI R29 Undefined
        CFI R30 Undefined
        CFI R31 Undefined
        CFI ?RetHighByteMask SameValue
        CFI SPH Undefined
        CFI SPL Undefined
        CFI EndCommon cfiCommon0
        
// f:\Projects\[Drivers]\C\MROS\Peripherals\UART.c
//    1 #include "UART.h"

        ASEGN ABSOLUTE:DATA:NOROOT,029H
// union <unnamed> volatile __io _A_UBRRL
_A_UBRRL:
        DS 1

        ASEGN ABSOLUTE:DATA:NOROOT,02aH
// union <unnamed> volatile __io _A_UCSRB
_A_UCSRB:
        DS 1

        ASEGN ABSOLUTE:DATA:NOROOT,02bH
// union <unnamed> volatile __io _A_UCSRA
_A_UCSRA:
        DS 1

        ASEGN ABSOLUTE:DATA:NOROOT,02cH
// union <unnamed> volatile __io _A_UDR
_A_UDR:
        DS 1

        ASEGN ABSOLUTE:DATA:NOROOT,040H
// union <unnamed> volatile __io _A_UBRRH
_A_UBRRH:
        DS 1
//    2 
//    3 
//    4 #if defined(BUFFERED_UART_)
//    5 static unsigned char RxBuffer[RX_BUFFER_SIZE];
//    6 static unsigned char RxBufferIn=0;
//    7 static unsigned char RxBufferOut=0;
//    8 static unsigned char RxBufferFull=0;
//    9 
//   10 static unsigned char TxBuffer[TX_BUFFER_SIZE];
//   11 static unsigned char TxBufferIn=0;
//   12 static unsigned char TxBufferOut=0;
//   13 static unsigned char TxBufferFull=0;
//   14 #endif
//   15 
//   16 
//   17 
//   18 static void WriteHexDigit(unsigned char value);
//   19 
//   20 
//   21 /**************************************************************
//   22 
//   23 **************************************************************/

        RSEG CODE:CODE:NOROOT(1)
//   24 void UART_Init(unsigned short baudrate)
UART_Init:
        CFI Block cfiBlock0 Using cfiCommon0
        CFI Function UART_Init
//   25 {
//   26 #if defined(__IOM64_H) || defined(__IOM162_H) || defined(__IOM168_H)
//   27 	UBRR0H=(baudrate>>8);
//   28 	UBRR0L=(baudrate&0xff);
//   29 	UCSR0A=(1<<U2X0);
//   30 #elif defined(__IOM32_H) || defined(__IOM8_H)
//   31 	UBRRH=(baudrate>>8);
        OUT     0x20, R17
//   32 	UBRRL=(baudrate&0xff);
        OUT     0x09, R16
//   33 	UCSRA=(1<<U2X);
        LDI     R16, 2
        OUT     0x0B, R16
//   34 #else
//   35 #error Module UART_ does not support the selected processor!
//   36 #endif
//   37 
//   38 #if defined(BUFFERED_UART_)
//   39 
//   40 #if defined(__IOM64_H) || defined(__IOM162_H) || defined(__IOM168_H)
//   41 	UCSR0B=(1<<RXCIE0)|(1<<RXEN0)|(1<<TXEN0);
//   42 #elif defined(__IOM32_H) || defined(__IOM8_H)
//   43 	UCSRB=(1<<RXCIE)|(1<<RXEN)|(1<<TXEN);
//   44 #else
//   45 #error Module UART_ does not support the selected processor!
//   46 #endif
//   47 
//   48 #else
//   49 
//   50 #if defined(__IOM64_H) || defined(__IOM162_H) || defined(__IOM168_H)
//   51 	UCSR0B=(1<<RXEN0)|(1<<TXEN0);
//   52 #elif defined(__IOM32_H) || defined(__IOM8_H)
//   53 	UCSRB=(1<<RXEN)|(1<<TXEN);
        LDI     R16, 24
        OUT     0x0A, R16
//   54 #else
//   55 #error Module UART_ does not support the selected processor!
//   56 #endif
//   57 
//   58 #endif
//   59 
//   60 }
        RET
        CFI EndBlock cfiBlock0
//   61 
//   62 
//   63 /**************************************************************
//   64 
//   65 **************************************************************/

        RSEG CODE:CODE:NOROOT(1)
//   66 void UART_SetBaudrate(unsigned short baudrate)
UART_SetBaudrate:
        CFI Block cfiBlock1 Using cfiCommon0
        CFI Function UART_SetBaudrate
//   67 {
//   68 #if defined(__IOM64_H) || defined(__IOM162_H) || defined(__IOM168_H)
//   69 	UBRR0H=(baudrate>>8);
//   70 	UBRR0L=(baudrate&0xff);
//   71 #elif defined(__IOM32_H) || defined(__IOM8_H)
//   72 	UBRRH=(baudrate>>8);
        OUT     0x20, R17
//   73 	UBRRL=(baudrate&0xff);
        OUT     0x09, R16
//   74 #else
//   75 #error Module UART_ does not support the selected processor!
//   76 #endif
//   77 }
        RET
        CFI EndBlock cfiBlock1
//   78 
//   79 /**************************************************************
//   80 
//   81 **************************************************************/

        RSEG CODE:CODE:NOROOT(1)
//   82 unsigned char UART_BytesReady(void)
UART_BytesReady:
        CFI Block cfiBlock2 Using cfiCommon0
        CFI Function UART_BytesReady
//   83 {
//   84 #if defined(BUFFERED_UART_)
//   85 	if(RxBufferFull)
//   86 		return RX_BUFFER_SIZE;
//   87 	else
//   88 	{
//   89 		if(RxBufferIn==RxBufferOut)
//   90 			return 0;
//   91 		else if(RxBufferIn>RxBufferOut)
//   92 			return (RxBufferIn-RxBufferOut);
//   93 		else
//   94 			return (RX_BUFFER_SIZE-(RxBufferOut-RxBufferIn));
//   95 	}
//   96 
//   97 #else
//   98 
//   99 #if defined(__IOM64_H) || defined(__IOM162_H) || defined(__IOM168_H)
//  100 	return ((UCSR0A&(1<<RXC0))!=0);
//  101 #elif defined(__IOM32_H) || defined(__IOM8_H)
//  102 	return ((UCSRA&(1<<RXC))!=0);
        LDI     R16, 0
        SBIC    0x0B, 0x07
        LDI     R16, 1
??UART_BytesReady_0:
        RET
        CFI EndBlock cfiBlock2
//  103 #else
//  104 #error Module UART_ does not support the selected processor!
//  105 #endif
//  106 
//  107 #endif
//  108 }
//  109 
//  110 
//  111 /**************************************************************
//  112 
//  113 **************************************************************/

        RSEG CODE:CODE:NOROOT(1)
//  114 unsigned char UART_ReadByte(void)
UART_ReadByte:
??UART_ReadByte_0:
        CFI Block cfiBlock3 Using cfiCommon0
        CFI Function UART_ReadByte
//  115 {
//  116 #if defined(BUFFERED_UART_)
//  117 unsigned char Temp;
//  118 
//  119 	while(UART_BytesReady()==0);
//  120 
//  121 	Temp=RxBuffer[RxBufferOut++];
//  122 	if(RxBufferOut>=RX_BUFFER_SIZE)
//  123 		RxBufferOut=0;
//  124 	RxBufferFull=0;
//  125 	return Temp;
//  126 
//  127 #else
//  128 
//  129 #if defined(__IOM64_H) || defined(__IOM162_H) || defined(__IOM168_H)
//  130 	while(!(UCSR0A&(1<<RXC0)));
//  131 	return UDR0;
//  132 #elif defined(__IOM32_H) || defined(__IOM8_H)
//  133 	while(!(UCSRA&(1<<RXC)));
        SBIS    0x0B, 0x07
        RJMP    ??UART_ReadByte_0
//  134 	return UDR;
        IN      R16, 0x0C
        RET
        CFI EndBlock cfiBlock3
//  135 #else
//  136 #error Module UART_ does not support the selected processor!
//  137 #endif
//  138 
//  139 #endif
//  140 }
//  141 
//  142 
//  143 /**************************************************************
//  144 
//  145 **************************************************************/

        RSEG CODE:CODE:NOROOT(1)
//  146 void UART_ReadBytes(unsigned char *buffer, unsigned char length)
UART_ReadBytes:
        CFI Block cfiBlock4 Using cfiCommon0
        CFI Function UART_ReadBytes
//  147 {
        FUNCALL UART_ReadBytes, UART_ReadByte
        LOCFRAME CSTACK, 3, STACK
        LOCFRAME RSTACK, 2, STACK
        ST      -Y, R27
        CFI R27 Frame(CFA_Y, -1)
        CFI CFA_Y Y+1
        ST      -Y, R26
        CFI R26 Frame(CFA_Y, -2)
        CFI CFA_Y Y+2
        ST      -Y, R24
        CFI R24 Frame(CFA_Y, -3)
        CFI CFA_Y Y+3
        MOVW    R27:R26, R17:R16
        MOV     R24, R18
        TST     R18
        BREQ    ??UART_ReadBytes_0
//  148 	while(length)
//  149 	{
//  150 		*buffer++=UART_ReadByte();
??UART_ReadBytes_1:
        RCALL   UART_ReadByte
        ST      X+, R16
//  151 		length--;
        DEC     R24
//  152 	}
        BRNE    ??UART_ReadBytes_1
//  153 }
??UART_ReadBytes_0:
        LD      R24, Y+
        CFI R24 SameValue
        CFI CFA_Y Y+2
        LD      R26, Y+
        CFI R26 SameValue
        CFI CFA_Y Y+1
        LD      R27, Y+
        CFI R27 SameValue
        CFI CFA_Y Y+0
        RET
        CFI EndBlock cfiBlock4
//  154 
//  155 
//  156 /**************************************************************
//  157 
//  158 **************************************************************/

        RSEG CODE:CODE:NOROOT(1)
//  159 void UART_WriteByte(unsigned char data)
UART_WriteByte:
??UART_WriteByte_0:
        CFI Block cfiBlock5 Using cfiCommon0
        CFI Function UART_WriteByte
//  160 {
//  161 #if defined(BUFFERED_UART_)
//  162 
//  163 	while(TxBufferFull);
//  164 
//  165 //	if(UCSRA&(1<<UDRE))
//  166 //		UDR=Data;
//  167 //	else
//  168 //	{
//  169 		TxBuffer[TxBufferIn++]=data;
//  170 		if(TxBufferIn>=TX_BUFFER_SIZE)
//  171 			TxBufferIn=0;
//  172 		if(TxBufferIn==TxBufferOut)
//  173 			TxBufferFull=1;
//  174 		else
//  175 			TxBufferFull=0;
//  176 		UCSRB|=(1<<UDRIE);
//  177 //	}
//  178 
//  179 #else
//  180 
//  181 #if defined(__IOM64_H) || defined(__IOM162_H) || defined(__IOM168_H)
//  182 	while(!(UCSR0A&(1<<UDRE0)));
//  183 	UDR0=data;
//  184 #elif defined(__IOM32_H) || defined(__IOM8_H)
//  185 	while(!(UCSRA&(1<<UDRE)));
        SBIS    0x0B, 0x05
        RJMP    ??UART_WriteByte_0
//  186 	UDR=data;
        OUT     0x0C, R16
//  187 #else
//  188 #error Module UART_ does not support the selected processor!
//  189 #endif
//  190 
//  191 #endif
//  192 }
        RET
        CFI EndBlock cfiBlock5
//  193 
//  194 
//  195 /**************************************************************
//  196 
//  197 **************************************************************/

        RSEG CODE:CODE:NOROOT(1)
//  198 void putc(unsigned char data)
putc:
??putc_0:
        CFI Block cfiBlock6 Using cfiCommon0
        CFI Function putc
//  199 {
//  200 	UART_WriteByte(data);
        SBIS    0x0B, 0x05
        RJMP    ??putc_0
        OUT     0x0C, R16
//  201 }
        RET
        CFI EndBlock cfiBlock6

        RSEG CODE:CODE:NOROOT(1)
//  202 int putchar(int data)
putchar:
??putchar_0:
        CFI Block cfiBlock7 Using cfiCommon0
        CFI Function putchar
//  203 {
//  204 	UART_WriteByte(data);
        SBIS    0x0B, 0x05
        RJMP    ??putchar_0
        OUT     0x0C, R16
//  205 	return 0;
        LDI     R16, 0
        LDI     R17, 0
        RET
        CFI EndBlock cfiBlock7
//  206 }
//  207 
//  208 
//  209 /**************************************************************
//  210 
//  211 **************************************************************/

        RSEG CODE:CODE:NOROOT(1)
//  212 unsigned char getc(void)
getc:
        CFI Block cfiBlock8 Using cfiCommon0
        CFI Function getc
//  213 {
//  214 	return UART_ReadByte();
        FUNCALL getc, UART_ReadByte
        LOCFRAME RSTACK, 2, STACK
        RJMP    UART_ReadByte
        CFI EndBlock cfiBlock8
//  215 }
//  216 
//  217 
//  218 /**************************************************************
//  219 
//  220 **************************************************************/

        RSEG CODE:CODE:NOROOT(1)
//  221 void UART_WriteBytes(unsigned char *buffer, unsigned char length)
UART_WriteBytes:
        CFI Block cfiBlock9 Using cfiCommon0
        CFI Function UART_WriteBytes
//  222 {
        TST     R18
        BREQ    ??UART_WriteBytes_0
//  223 	while(length)
//  224 	{
//  225 		length--;
??UART_WriteBytes_1:
        DEC     R18
//  226 		UART_WriteByte(*buffer++);
        MOVW    R31:R30, R17:R16
        LD      R19, Z
??UART_WriteBytes_2:
        SBIS    0x0B, 0x05
        RJMP    ??UART_WriteBytes_2
        OUT     0x0C, R19
        SUBI    R16, 255
        SBCI    R17, 255
//  227 	}
        TST     R18
        BRNE    ??UART_WriteBytes_1
//  228 }
??UART_WriteBytes_0:
        RET
        CFI EndBlock cfiBlock9
//  229 
//  230 
//  231 /**************************************************************
//  232 
//  233 **************************************************************/
//  234 #if defined(BUFFERED_UART_)
//  235 #if defined(__IOM162_H) || defined(__IOM168_H)
//  236 #pragma vector=USART0_RXC_vect
//  237 #elif
//  238 #error Module 'UART' does not support the selected processor!
//  239 //#pragma vector=USART_RXC_vect
//  240 #endif
//  241 __interrupt void UART__RX_Interrupt(void)
//  242 {
//  243 unsigned char temp;
//  244 
//  245 #if defined(__IOM64_H) || defined(__IOM162_h)
//  246 	temp=UDR0;
//  247 #elif defined(__IOM32_H) || defined(__IOM8_H)
//  248 	temp=UDR;
//  249 #else
//  250 #error Module 'UART' does not support the selected processor!
//  251 #endif
//  252 	if(!RxBufferFull)
//  253 	{
//  254 		RxBuffer[RxBufferIn++]=temp;
//  255 		if(RxBufferIn>=RX_BUFFER_SIZE)
//  256 			RxBufferIn=0;
//  257 		if(RxBufferIn==RxBufferOut)
//  258 			RxBufferFull=1;
//  259 		else
//  260 			RxBufferFull=0;
//  261 	}
//  262 }
//  263 #endif
//  264 
//  265 
//  266 /**************************************************************
//  267 
//  268 **************************************************************/
//  269 #if defined(BUFFERED_UART_)
//  270 #if defined(__IOM162_H) || defined(__IOM168_H)
//  271 #pragma vector=USART0_UDRE_vect
//  272 #elif
//  273 #error Module 'UART' does not support the selected processor!
//  274 //#pragma vector=USART_UDRE_vect
//  275 #endif
//  276 __interrupt void UART__UDRE_Interrupt(void)
//  277 {
//  278 	if(TxBufferFull || (TxBufferIn!=TxBufferOut))
//  279 	{
//  280 #if defined(__IOM64_H) || defined(__IOM162_h)
//  281 		UDR0=TxBuffer[TxBufferOut++];
//  282 #elif defined(__IOM32_H) || defined(__IOM8_H)
//  283 		UDR=TxBuffer[TxBufferOut++];
//  284 #else
//  285 #error Module UART_ does not support the selected processor!
//  286 #endif
//  287 		if(TxBufferOut>=TX_BUFFER_SIZE)
//  288 			TxBufferOut=0;
//  289 		TxBufferFull=0;
//  290 	}
//  291 	else
//  292 #if defined(__IOM64_H) || defined(__IOM162_h)
//  293 		UCSR0B&=~(1<<UDRIE0);
//  294 #elif defined(__IOM32_H) || defined(__IOM8_H)
//  295 		UCSRB&=~(1<<UDRIE);
//  296 #else
//  297 #error Module UART_ does not support the selected processor!
//  298 #endif
//  299 }
//  300 #endif
//  301 
//  302 
//  303 
//  304 /**************************************************************
//  305 
//  306 **************************************************************/

        RSEG CODE:CODE:NOROOT(1)
//  307 void UART_WriteString(char* str)
UART_WriteString:
        CFI Block cfiBlock10 Using cfiCommon0
        CFI Function UART_WriteString
//  308 {
        RJMP    ??UART_WriteString_0
//  309 unsigned char temp;
//  310 
//  311 	while(*str)
//  312 	{
//  313 		temp=*str++;
??UART_WriteString_1:
        ADIW    R31:R30, 1
        MOVW    R17:R16, R31:R30
//  314 #if (SEND_CRLF==1)
//  315 		if(temp==10)
//  316 			UART_WriteByte(13);
//  317 #endif
//  318 		UART_WriteByte(temp);
??UART_WriteString_2:
        SBIS    0x0B, 0x05
        RJMP    ??UART_WriteString_2
        OUT     0x0C, R18
//  319 	}
??UART_WriteString_0:
        MOVW    R31:R30, R17:R16
        LD      R18, Z
        TST     R18
        BRNE    ??UART_WriteString_1
//  320 }
        RET
        CFI EndBlock cfiBlock10
//  321 
//  322 
//  323 /**************************************************************
//  324 
//  325 **************************************************************/

        RSEG CODE:CODE:NOROOT(1)
//  326 void UART_WriteString_P(string* str)
UART_WriteString_P:
        CFI Block cfiBlock11 Using cfiCommon0
        CFI Function UART_WriteString_P
//  327 {
        RJMP    ??UART_WriteString_P_0
//  328 unsigned char temp;
//  329 
//  330 	while(*str)
//  331 	{
//  332 		temp=*str++;
??UART_WriteString_P_1:
        LPM     R18, Z+
        MOVW    R17:R16, R31:R30
//  333 #if (SEND_CRLF==1)
//  334 		if(temp==10)
//  335 			UART_WriteByte(13);
//  336 #endif
//  337 		UART_WriteByte(temp);
??UART_WriteString_P_2:
        SBIS    0x0B, 0x05
        RJMP    ??UART_WriteString_P_2
        OUT     0x0C, R18
//  338 	}
??UART_WriteString_P_0:
        MOVW    R31:R30, R17:R16
        LPM     R18, Z
        TST     R18
        BRNE    ??UART_WriteString_P_1
//  339 }
        RET
        CFI EndBlock cfiBlock11
//  340 
//  341 
//  342 
//  343 /**************************************************************
//  344 
//  345 **************************************************************/

        RSEG CODE:CODE:NOROOT(1)
//  346 void UART_WriteValueUnsigned(unsigned long value)
UART_WriteValueUnsigned:
        CFI Block cfiBlock12 Using cfiCommon0
        CFI Function UART_WriteValueUnsigned
//  347 {
        ST      -Y, R27
        CFI R27 Frame(CFA_Y, -1)
        CFI CFA_Y Y+1
        ST      -Y, R26
        CFI R26 Frame(CFA_Y, -2)
        CFI CFA_Y Y+2
        ST      -Y, R25
        CFI R25 Frame(CFA_Y, -3)
        CFI CFA_Y Y+3
        MOV     R31, R24
        MOVW    R25:R24, R17:R16
        MOVW    R27:R26, R19:R18
//  348 	if(value > 999999)
        CPI     R16, 64
        LDI     R16, 66
        CPC     R25, R16
        LDI     R16, 15
        CPC     R26, R16
        LDI     R16, 0
        CPC     R27, R16
        BRCS    ??UART_WriteValueUnsigned_0
//  349 	{
//  350 		UART_WriteByte(((value / 1000000) % 10) + '0');
        MOVW    R17:R16, R25:R24
        LDI     R20, 64
        LDI     R21, 66
        LDI     R22, 15
        LDI     R23, 0
        CALL    ?UL_DIVMOD_L03
        LDI     R20, 10
        LDI     R21, 0
        LDI     R22, 0
        LDI     R23, 0
        CALL    ?UL_DIVMOD_L03
        SUBI    R20, 208
??UART_WriteValueUnsigned_1:
        SBIS    0x0B, 0x05
        RJMP    ??UART_WriteValueUnsigned_1
        OUT     0x0C, R20
        RJMP    ??UART_WriteValueUnsigned_2
//  351 	}
//  352 	if(value > 99999)
??UART_WriteValueUnsigned_0:
        CPI     R24, 160
        LDI     R16, 134
        CPC     R25, R16
        LDI     R16, 1
        CPC     R26, R16
        LDI     R16, 0
        CPC     R27, R16
        BRCS    ??UART_WriteValueUnsigned_3
//  353 	{
//  354 		UART_WriteByte(((value / 100000) % 10) + '0');
??UART_WriteValueUnsigned_2:
        MOVW    R17:R16, R25:R24
        MOVW    R19:R18, R27:R26
        LDI     R20, 160
        LDI     R21, 134
        LDI     R22, 1
        LDI     R23, 0
        CALL    ?UL_DIVMOD_L03
        LDI     R20, 10
        LDI     R21, 0
        LDI     R22, 0
        LDI     R23, 0
        CALL    ?UL_DIVMOD_L03
        SUBI    R20, 208
??UART_WriteValueUnsigned_4:
        SBIS    0x0B, 0x05
        RJMP    ??UART_WriteValueUnsigned_4
        OUT     0x0C, R20
        RJMP    ??UART_WriteValueUnsigned_5
//  355 	}
//  356 	if(value > 9999)
??UART_WriteValueUnsigned_3:
        CPI     R24, 16
        LDI     R16, 39
        CPC     R25, R16
        LDI     R16, 0
        CPC     R26, R16
        CPC     R27, R16
        BRCS    ??UART_WriteValueUnsigned_6
//  357 	{
//  358 		UART_WriteByte(((value / 10000) % 10) + '0');
??UART_WriteValueUnsigned_5:
        MOVW    R17:R16, R25:R24
        MOVW    R19:R18, R27:R26
        LDI     R20, 16
        LDI     R21, 39
        LDI     R22, 0
        LDI     R23, 0
        CALL    ?UL_DIVMOD_L03
        LDI     R20, 10
        LDI     R21, 0
        LDI     R22, 0
        LDI     R23, 0
        CALL    ?UL_DIVMOD_L03
        SUBI    R20, 208
??UART_WriteValueUnsigned_7:
        SBIS    0x0B, 0x05
        RJMP    ??UART_WriteValueUnsigned_7
        OUT     0x0C, R20
        RJMP    ??UART_WriteValueUnsigned_8
//  359 	}
//  360 	if(value > 999)
??UART_WriteValueUnsigned_6:
        CPI     R24, 232
        LDI     R16, 3
        CPC     R25, R16
        LDI     R16, 0
        CPC     R26, R16
        CPC     R27, R16
        BRCS    ??UART_WriteValueUnsigned_9
//  361 	{
//  362 		UART_WriteByte(((value / 1000) % 10) + '0');
??UART_WriteValueUnsigned_8:
        MOVW    R17:R16, R25:R24
        MOVW    R19:R18, R27:R26
        LDI     R20, 232
        LDI     R21, 3
        LDI     R22, 0
        LDI     R23, 0
        CALL    ?UL_DIVMOD_L03
        LDI     R20, 10
        LDI     R21, 0
        LDI     R22, 0
        LDI     R23, 0
        CALL    ?UL_DIVMOD_L03
        SUBI    R20, 208
??UART_WriteValueUnsigned_10:
        SBIS    0x0B, 0x05
        RJMP    ??UART_WriteValueUnsigned_10
        OUT     0x0C, R20
        RJMP    ??UART_WriteValueUnsigned_11
//  363 	}
//  364 	if(value > 99)
??UART_WriteValueUnsigned_9:
        CPI     R24, 100
        CPC     R25, R16
        CPC     R26, R16
        CPC     R27, R16
        BRCS    ??UART_WriteValueUnsigned_12
//  365 	{
//  366 		UART_WriteByte(((value / 100) % 10) + '0');
??UART_WriteValueUnsigned_11:
        MOVW    R17:R16, R25:R24
        MOVW    R19:R18, R27:R26
        LDI     R20, 100
        LDI     R21, 0
        LDI     R22, 0
        LDI     R23, 0
        CALL    ?UL_DIVMOD_L03
        LDI     R20, 10
        LDI     R21, 0
        LDI     R22, 0
        LDI     R23, 0
        CALL    ?UL_DIVMOD_L03
        SUBI    R20, 208
??UART_WriteValueUnsigned_13:
        SBIS    0x0B, 0x05
        RJMP    ??UART_WriteValueUnsigned_13
        OUT     0x0C, R20
        RJMP    ??UART_WriteValueUnsigned_14
//  367 	}
//  368 	if(value > 9)
??UART_WriteValueUnsigned_12:
        CPI     R24, 10
        CPC     R25, R16
        CPC     R26, R16
        CPC     R27, R16
        BRCS    ??UART_WriteValueUnsigned_15
//  369 	{
//  370 		UART_WriteByte(((value / 10) % 10) + '0');
??UART_WriteValueUnsigned_14:
        MOVW    R17:R16, R25:R24
        MOVW    R19:R18, R27:R26
        LDI     R20, 10
        LDI     R21, 0
        LDI     R22, 0
        LDI     R23, 0
        CALL    ?UL_DIVMOD_L03
        LDI     R20, 10
        LDI     R21, 0
        LDI     R22, 0
        LDI     R23, 0
        CALL    ?UL_DIVMOD_L03
        SUBI    R20, 208
??UART_WriteValueUnsigned_16:
        SBIS    0x0B, 0x05
        RJMP    ??UART_WriteValueUnsigned_16
        OUT     0x0C, R20
//  371 	}
//  372 	UART_WriteByte((value % 10) + '0');
??UART_WriteValueUnsigned_15:
        MOVW    R17:R16, R25:R24
        MOVW    R19:R18, R27:R26
        LDI     R20, 10
        LDI     R21, 0
        LDI     R22, 0
        LDI     R23, 0
        CALL    ?UL_DIVMOD_L03
        SUBI    R20, 208
??UART_WriteValueUnsigned_17:
        SBIS    0x0B, 0x05
        RJMP    ??UART_WriteValueUnsigned_17
        OUT     0x0C, R20
//  373 }
        MOV     R24, R31
        LD      R25, Y+
        CFI R31 R24
        CFI R24 R31
        CFI R25 SameValue
        CFI CFA_Y Y+2
        LD      R26, Y+
        CFI R26 SameValue
        CFI CFA_Y Y+1
        LD      R27, Y+
        CFI R27 SameValue
        CFI CFA_Y Y+0
        RET
        CFI EndBlock cfiBlock12
//  374 
//  375 

        RSEG CODE:CODE:NOROOT(1)
//  376 void UART_WritePointer(void* pointer)
UART_WritePointer:
        CFI Block cfiBlock13 Using cfiCommon0
        CFI Function UART_WritePointer
//  377 {
        FUNCALL UART_WritePointer, WriteHexDigit
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL UART_WritePointer, WriteHexDigit
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL UART_WritePointer, WriteHexDigit
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL UART_WritePointer, WriteHexDigit
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        ST      -Y, R27
        CFI R27 Frame(CFA_Y, -1)
        CFI CFA_Y Y+1
        ST      -Y, R26
        CFI R26 Frame(CFA_Y, -2)
        CFI CFA_Y Y+2
        ST      -Y, R24
        CFI R24 Frame(CFA_Y, -3)
        CFI CFA_Y Y+3
        MOV     R24, R16
//  378 	WriteHexDigit((unsigned short)pointer >> 12);
        MOVW    R27:R26, R17:R16
        MOV     R16, R17
        LSR     R16
        LSR     R16
        LSR     R16
        LSR     R16
        RCALL   WriteHexDigit
//  379 	WriteHexDigit((unsigned short)pointer >> 8);
        MOV     R16, R27
        RCALL   WriteHexDigit
//  380 	WriteHexDigit((unsigned short)pointer >> 4);
        LSR     R27
        ROR     R26
        LSR     R27
        ROR     R26
        LSR     R27
        ROR     R26
        LSR     R27
        ROR     R26
        MOV     R16, R26
        RCALL   WriteHexDigit
//  381 	WriteHexDigit((unsigned short)pointer);
        MOV     R16, R24
        RCALL   WriteHexDigit
//  382 }
        LD      R24, Y+
        CFI R24 SameValue
        CFI CFA_Y Y+2
        LD      R26, Y+
        CFI R26 SameValue
        CFI CFA_Y Y+1
        LD      R27, Y+
        CFI R27 SameValue
        CFI CFA_Y Y+0
        RET
        CFI EndBlock cfiBlock13
//  383 
//  384 

        RSEG CODE:CODE:NOROOT(1)
//  385 static void WriteHexDigit(unsigned char value)
WriteHexDigit:
        CFI Block cfiBlock14 Using cfiCommon0
        CFI Function WriteHexDigit
//  386 {
//  387 	value &= 0x0f;
        ANDI    R16, 0x0F
//  388 	
//  389 	if(value > 9)
        CPI     R16, 10
        BRCS    ??WriteHexDigit_0
//  390 		UART_WriteByte(value + 'A' - 10);
        SUBI    R16, 201
??WriteHexDigit_1:
        SBIS    0x0B, 0x05
        RJMP    ??WriteHexDigit_1
        RJMP    ??WriteHexDigit_2
//  391 	else
//  392 		UART_WriteByte(value + '0');
??WriteHexDigit_0:
        SUBI    R16, 208
??WriteHexDigit_3:
        SBIS    0x0B, 0x05
        RJMP    ??WriteHexDigit_3
??WriteHexDigit_2:
        OUT     0x0C, R16
//  393 }
        RET
        CFI EndBlock cfiBlock14

        ASEGN ABSOLUTE:DATA:NOROOT,01cH
__?EECR:

        ASEGN ABSOLUTE:DATA:NOROOT,01dH
__?EEDR:

        ASEGN ABSOLUTE:DATA:NOROOT,01eH
__?EEARL:

        ASEGN ABSOLUTE:DATA:NOROOT,01fH
__?EEARH:

        END
//  394 
//  395 /**************************************************************
//  396 
//  397 **************************************************************/
//  398 /*
//  399 void UART__WriteShort(unsigned short Data)
//  400 {
//  401 	if(Data>9999)
//  402 		UART_WriteByte((Data/10000)%10+'0');
//  403 	if(Data>999)
//  404 		UART_WriteByte((Data/1000)%10+'0');
//  405 	if(Data>99)
//  406 		UART_WriteByte((Data/100)%10+'0');
//  407 	if(Data>9)
//  408 		UART_WriteByte((Data/10)%10+'0');
//  409 	UART_WriteByte(Data%10+'0');
//  410 }
//  411 */
//  412 
//  413 /**************************************************************
//  414 
//  415 **************************************************************/
//  416 /*
//  417 void Flush(void)
//  418 {
//  419 	while(UART_BytesReady())
//  420 		UART_ReadByte();
//  421 }
//  422 */
// 
//   5 bytes in segment ABSOLUTE
// 598 bytes in segment CODE
// 
// 598 bytes of CODE memory
//   0 bytes of DATA memory (+ 5 bytes shared)
//
//Errors: none
//Warnings: none
