##############################################################################
#                                                                            #
# IAR Atmel AVR C/EC++ Compiler V2.28A/WIN, Evaluation Version04/Dec/2007  19:35:45 #
# Copyright 1996-2002 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Source file  =  f:\Projects\[Drivers]\C\MROS\Network\ARP.c              #
#    Command line =  --cpu=m32 -ms -o f:\Projects\[Drivers]\C\MROS\TestApps\ #
#                    NetworkTester\Release\Obj\ -I "C:\Program Files\IAR     #
#                    Systems\Ew23 Evaluation version\avr\SRC\CLIB\INC\" -I   #
#                    f:\Projects\[Drivers]\C\MROS\TestApps\NetworkTester\    #
#                    -I f:\Projects\[Drivers]\C\MROS\ -I                     #
#                    f:\Projects\[Drivers]\C\MROS\Network\ -lC               #
#                    f:\Projects\[Drivers]\C\MROS\TestApps\NetworkTester\Rel #
#                    ease\List\ -e --initializers_in_flash -s9 --debug       #
#                    -DENABLE_BIT_DEFINITIONS f:\Projects\[Drivers]\C\MROS\N #
#                    etwork\ARP.c                                            #
#    List file    =  f:\Projects\[Drivers]\C\MROS\TestApps\NetworkTester\Rel #
#                    ease\List\ARP.lst                                       #
#    Object file  =  f:\Projects\[Drivers]\C\MROS\TestApps\NetworkTester\Rel #
#                    ease\Obj\ARP.r90                                        #
#                                                                            #
#                                                                            #
##############################################################################

      1          #include "Network.h"
      2          #include <Kernel/Kernel.h>
      3          
      4          /*
      5          	ARP packet format
      6          
      7          	
      8          			0				1				2				3				4				5				6				7				8
      9          
     10          			*-------*-------*-------*-------*-------*-------*-------*-------*
     11          	0		| Hardware Type | Protocol Type | H Len | P Len |   Operation   |
     12          			*-------*-------*-------*-------*-------*-------*-------*-------*
     13          	8		|            Senders Hardware Address           | Senders Proto-|
     14          			*-------*-------*-------*-------*-------*-------*-------*-------*
     15          	16	|  col Address  |           Targets Hardware Address            |
     16          			*-------*-------*-------*-------*-------*-------*-------*-------*
     17          	24	|  	Targets Protocol Address    |
     18          			*-------*-------*-------*-------*
     19          
     20          	Hardware Type:							0x0001 means Ethernet.
     21          	Protocol Type:							0x0800 means IP.
     22          	H Len:											Hardware address length. Length of the MAC adress. Always 6.
     23          	P Len:											Protocol address length. Length of the IP address. Always 4.
     24          	Op Code:										ARP operation:	1 - Unknown
     25          																							2 - ARP Request
     26          																							3 - ARP Response
     27          	Senders Hardware Address:		The MAC address on Ethernet.
     28          	Senders Protocol Address:		The IP address in TCP/IP
     29          	Targets Hardware Address:		The MAC address on Ethernet.
     30          	Targets Protocol Address:		The IP address in TCP/IP
     31          
     32          	Some of the fields may appear to have strange names or to be superfluous but keep
     33          	in mind that ARP can be used outside the Ethernet domain.
     34          	
     35          	Operation:
     36          
     37          		To obtain the MAC associated with a known IP broadcast an ARP request packet
     38          
     39          */
     40          
     41          
     42          typedef struct
     43          {
     44          	unsigned long ip;
     45          	unsigned char mac[6];
     46          	unsigned short age;
     47          } ARP_ENTRY;
     48          

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
     49          ARP_ENTRY arpTable[ARP_TABLE_SIZE];
   \   struct <unnamed> __near arpTable[3];
   \                     arpTable:
   \   00000000                              DS 36
     50          
     51          

   \                                 In segment CODE, align 2, keep-with-next
     52          void ARP_Receive(unsigned char *buffer)
     53          {
   \   __nearfunc void ARP_Receive(unsigned char *);
   \                     ARP_Receive:
   \   00000000   93BA                       ST      -Y,R27
   \   00000002   93AA                       ST      -Y,R26
   \   00000004   939A                       ST      -Y,R25
   \   00000006   938A                       ST      -Y,R24
   \   00000008   01C8                       MOVW    R25 : R24,R17 : R16
     54          unsigned char temp;
     55          
     56          	if(	(GetShort(buffer + ARP_HARDWARE_TYPE) == 0x0001) &&																// Hardware type is Ethernet
     57          			(GetShort(buffer + ARP_PROTOCOL_TYPE) == 0x0800) &&																// Protocol type is IP
     58          			(buffer[ARP_HARDWARE_ADDRESS_LENGTH] == 6) &&																			// MAC takes up 6 bytes
     59          			(buffer[ARP_PROTOCOL_ADDRESS_LENGTH] == 4)																				// IP address takes up 4 bytes
     60          		)
   \   0000000A   5F02                       SUBI    R16,242
   \   0000000C   4F1F                       SBCI    R17,255
   \   0000000E   ........                   CALL    GetShort
   \   00000012   3001                       CPI     R16,1
   \   00000014   4010                       SBCI    R17,0
   \   00000016   F009                       BREQ    ??ARP_Receive_0
   \   00000018   C05B                       RJMP    ??ARP_Receive_1
   \                     ??ARP_Receive_0:
   \   0000001A   018C                       MOVW    R17 : R16,R25 : R24
   \   0000001C   5F00                       SUBI    R16,240
   \   0000001E   4F1F                       SBCI    R17,255
   \   00000020   ........                   CALL    GetShort
   \   00000024   3000                       CPI     R16,0
   \   00000026   4018                       SBCI    R17,8
   \   00000028   F009                       BREQ    ??ARP_Receive_2
   \   0000002A   C052                       RJMP    ??ARP_Receive_1
   \                     ??ARP_Receive_2:
   \   0000002C   01FC                       MOVW    R31 : R30,R25 : R24
   \   0000002E   8902                       LDD     R16,Z+18
   \   00000030   9672                       ADIW    R31 : R30,18
   \   00000032   3006                       CPI     R16,6
   \   00000034   F009                       BREQ    ??ARP_Receive_3
   \   00000036   C04C                       RJMP    ??ARP_Receive_1
   \                     ??ARP_Receive_3:
   \   00000038   8101                       LDD     R16,Z+1
   \   0000003A   3004                       CPI     R16,4
   \   0000003C   F009                       BREQ    ??ARP_Receive_4
   \   0000003E   C048                       RJMP    ??ARP_Receive_1
     61          	{
     62          
     63          		switch(GetShort(buffer + ARP_OPERATION))																							// Switch on ARP operation
   \                     ??ARP_Receive_4:
   \   00000040   018C                       MOVW    R17 : R16,R25 : R24
   \   00000042   5E0C                       SUBI    R16,236
   \   00000044   4F1F                       SBCI    R17,255
   \   00000046   ........                   CALL    GetShort
   \   0000004A   01F8                       MOVW    R31 : R30,R17 : R16
   \   0000004C   9731                       SBIW    R31 : R30,1
   \   0000004E   F019                       BREQ    ??ARP_Receive_5
   \   00000050   9731                       SBIW    R31 : R30,1
   \   00000052   F1E1                       BREQ    ??ARP_Receive_6
   \   00000054   C03D                       RJMP    ??ARP_Receive_1
     64          		{
     65          			case ARP_OPERATION_REQUEST:				if(GetLong(buffer + ARP_TARGETS_PROTOCOL_ADDRESS) == ip)
   \                     ??ARP_Receive_5:
   \   00000056   018C                       MOVW    R17 : R16,R25 : R24
   \   00000058   5D0A                       SUBI    R16,218
   \   0000005A   4F1F                       SBCI    R17,255
   \   0000005C   ........                   CALL    GetLong
   \   00000060   ....                       LDI     R30,LOW(ip)
   \   00000062   ....                       LDI     R31,(ip) >> 8
   \   00000064   8140                       LD      R20,Z
   \   00000066   8151                       LDD     R21,Z+1
   \   00000068   8162                       LDD     R22,Z+2
   \   0000006A   8173                       LDD     R23,Z+3
   \   0000006C   1704                       CP      R16,R20
   \   0000006E   0715                       CPC     R17,R21
   \   00000070   0726                       CPC     R18,R22
   \   00000072   0737                       CPC     R19,R23
   \   00000074   F569                       BRNE    ??ARP_Receive_1
     66          																				{
     67          																					PutShort(buffer + ARP_OPERATION, ARP_OPERATION_RESPONSE);											// Now it's a reply
   \   00000076   E022                       LDI     R18,2
   \   00000078   E030                       LDI     R19,0
   \   0000007A   018C                       MOVW    R17 : R16,R25 : R24
   \   0000007C   5E0C                       SUBI    R16,236
   \   0000007E   4F1F                       SBCI    R17,255
   \   00000080   ........                   CALL    PutShort
     68          																					Swap(buffer + ARP_SENDERS_HARDWARE_ADDRESS, buffer + ARP_TARGETS_HARDWARE_ADDRESS, 10);
   \   00000084   E04A                       LDI     R20,10
   \   00000086   E050                       LDI     R21,0
   \   00000088   019C                       MOVW    R19 : R18,R25 : R24
   \   0000008A   5E20                       SUBI    R18,224
   \   0000008C   4F3F                       SBCI    R19,255
   \   0000008E   018C                       MOVW    R17 : R16,R25 : R24
   \   00000090   5E0A                       SUBI    R16,234
   \   00000092   4F1F                       SBCI    R17,255
   \   00000094   ........                   CALL    `Swap`
     69          																					for(temp = 0 ; temp < 6 ; temp++)
   \   00000098   01FC                       MOVW    R31 : R30,R25 : R24
   \   0000009A   9676                       ADIW    R31 : R30,22
   \   0000009C   ....                       LDI     R26,LOW(mac)
   \   0000009E   ....                       LDI     R27,(mac) >> 8
   \   000000A0   E006                       LDI     R16,6
     70          																					{
     71          																						buffer[ARP_SENDERS_HARDWARE_ADDRESS + temp] = mac[temp];
   \                     ??ARP_Receive_7:
   \   000000A2   911D                       LD      R17,X+
   \   000000A4   9311                       ST      Z+,R17
   \   000000A6   950A                       DEC     R16
   \   000000A8   F7E1                       BRNE    ??ARP_Receive_7
     72          																					}
     73          																					Clear(buffer + ETHERNET_HEADER_SIZE + IP_OPTIONS, 18);
   \   000000AA   E122                       LDI     R18,18
   \   000000AC   E030                       LDI     R19,0
   \   000000AE   018C                       MOVW    R17 : R16,R25 : R24
   \   000000B0   5D00                       SUBI    R16,208
   \   000000B2   4F1F                       SBCI    R17,255
   \   000000B4   ........                   CALL    Clear
     74          																					ETHERNET_Send(buffer + ETHERNET_SOURCE, ETHERNET_TYPE_ARP, buffer, 46);
   \   000000B8   E26E                       LDI     R22,46
   \   000000BA   E070                       LDI     R23,0
   \   000000BC   01AC                       MOVW    R21 : R20,R25 : R24
   \   000000BE   E026                       LDI     R18,6
   \   000000C0   E038                       LDI     R19,8
   \   000000C2   9606                       ADIW    R25 : R24,6
   \   000000C4   018C                       MOVW    R17 : R16,R25 : R24
   \   000000C6   ........                   CALL    ETHERNET_Send
   \   000000CA   C002                       RJMP    ??ARP_Receive_1
     75          																				}
     76          																				break;
     77          
     78          			case ARP_OPERATION_RESPONSE:			ARP_Cache(buffer);
   \                     ??ARP_Receive_6:
   \   000000CC   018C                       MOVW    R17 : R16,R25 : R24
   \   000000CE   ....                       RCALL   ARP_Cache
     79          																				break;
     80          		}
     81          	}
     82          }
   \                     ??ARP_Receive_1:
   \   000000D0   9189                       LD      R24,Y+
   \   000000D2   9199                       LD      R25,Y+
   \   000000D4   91A9                       LD      R26,Y+
   \   000000D6   91B9                       LD      R27,Y+
   \   000000D8   9508                       RET
     83          
     84          

   \                                 In segment CODE, align 2, keep-with-next
     85          unsigned char* ARP_Request(unsigned long ip)
     86          {
     87          	return 0;
   \   __nearfunc unsigned char *ARP_Request(unsigned long);
   \                     ARP_Request:
   \   00000000   E000                       LDI     R16,0
   \   00000002   E010                       LDI     R17,0
   \   00000004   9508                       RET
     88          }
     89          
     90          
     91          /*
     92          	Manages ageing of ARP entries. An entry is newer deleted but as it ages the chance that it will be overwriten increases.
     93          */

   \                                 In segment CODE, align 2, keep-with-next
     94          void ARP_Tick()
     95          {
     96          unsigned char temp;
     97          
     98          	for(temp = 0 ; temp < ARP_TABLE_SIZE ; temp++)
   \   __nearfunc void ARP_Tick();
   \                     ARP_Tick:
   \   00000000   ....                       LDI     R30,LOW((arpTable + 10))
   \   00000002   ....                       LDI     R31,(arpTable + 10) >> 8
   \   00000004   E003                       LDI     R16,3
     99          	{
    100          		if(arpTable[temp].age)
   \                     ??ARP_Tick_0:
   \   00000006   8120                       LD      R18,Z
   \   00000008   8131                       LDD     R19,Z+1
   \   0000000A   2B23                       OR      R18,R19
   \   0000000C   F031                       BREQ    ??ARP_Tick_1
    101          		{
    102          			arpTable[temp].age--;
   \   0000000E   8120                       LD      R18,Z
   \   00000010   8131                       LDD     R19,Z+1
   \   00000012   5021                       SUBI    R18,1
   \   00000014   4030                       SBCI    R19,0
   \   00000016   8320                       ST      Z,R18
   \   00000018   8331                       STD     Z+1,R19
   \                     ??ARP_Tick_1:
   \   0000001A   963C                       ADIW    R31 : R30,12
   \   0000001C   950A                       DEC     R16
   \   0000001E   F799                       BRNE    ??ARP_Tick_0
    103          		}
    104          	}
    105          	
    106          	Kernel_Sleep(SYSTEM_TICKS_PER_SECOND);																								// Sleep for a second
   \   00000020   EE08                       LDI     R16,232
   \   00000022   E013                       LDI     R17,3
   \   00000024   ........                   JMP     Kernel_Sleep
    107          }
    108          
    109          
    110          /*
    111          	Enters 'IP' into the table. If the IP already exists it's age is reset.
    112          */

   \                                 In segment CODE, align 2, keep-with-next
    113          void ARP_Cache(const unsigned char *buffer)
    114          {
   \   __nearfunc void ARP_Cache(unsigned char const *);
   \                     ARP_Cache:
   \   00000000   93BA                       ST      -Y,R27
   \   00000002   93AA                       ST      -Y,R26
   \   00000004   939A                       ST      -Y,R25
   \   00000006   938A                       ST      -Y,R24
   \   00000008   01C8                       MOVW    R25 : R24,R17 : R16
    115          unsigned char temp;
    116          unsigned long IP = GetLong(buffer + IP_SOURCE);
   \   0000000A   5E06                       SUBI    R16,230
   \   0000000C   4F1F                       SBCI    R17,255
   \   0000000E   ........                   CALL    GetLong
    117          unsigned char Oldest = 0;
   \   00000012   E000                       LDI     R16,0
    118          
    119          	for(temp = 0 ; temp < ARP_TABLE_SIZE ; temp++)
   \   00000014   E0A0                       LDI     R26,0
    120          	{
    121          		if(arpTable[temp].ip == ip)																															// If IP already exists
   \                     ??ARP_Cache_0:
   \   00000016   ....                       LDI     R30,LOW(arpTable)
   \   00000018   ....                       LDI     R31,(arpTable) >> 8
   \   0000001A   E0B0                       LDI     R27,0
   \   0000001C   E02C                       LDI     R18,12
   \   0000001E   E030                       LDI     R19,0
   \   00000020   9F3A                       MUL     R19,R26
   \   00000022   2D30                       MOV     R19,R0
   \   00000024   9F2B                       MUL     R18,R27
   \   00000026   0D30                       ADD     R19,R0
   \   00000028   9F2A                       MUL     R18,R26
   \   0000002A   0D31                       ADD     R19,R1
   \   0000002C   0DE0                       ADD     R30,R0
   \   0000002E   1FF3                       ADC     R31,R19
   \   00000030   8140                       LD      R20,Z
   \   00000032   8151                       LDD     R21,Z+1
   \   00000034   8162                       LDD     R22,Z+2
   \   00000036   8173                       LDD     R23,Z+3
   \   00000038   9000....                   LDS     R0,ip
   \   0000003C   9010....                   LDS     R1,(ip + 1)
   \   00000040   9020....                   LDS     R2,(ip + 2)
   \   00000044   9030....                   LDS     R3,(ip + 3)
   \   00000048   1540                       CP      R20,R0
   \   0000004A   0551                       CPC     R21,R1
   \   0000004C   0562                       CPC     R22,R2
   \   0000004E   0573                       CPC     R23,R3
   \   00000050   F461                       BRNE    ??ARP_Cache_1
    122          		{
    123          			arpTable[temp].age = ~0;																																// Reset it's age
   \   00000052   EF0F                       LDI     R16,255
   \   00000054   8702                       STD     Z+10,R16
   \   00000056   8703                       STD     Z+11,R16
    124          			MemCpy(buffer + ETHERNET_SOURCE, arpTable[temp].mac, 6);																	// Store MAC in case it has changed (is this really a good idea?)
   \   00000058   E046                       LDI     R20,6
   \   0000005A   E050                       LDI     R21,0
   \   0000005C   9634                       ADIW    R31 : R30,4
   \   0000005E   019F                       MOVW    R19 : R18,R31 : R30
   \   00000060   9606                       ADIW    R25 : R24,6
   \   00000062   018C                       MOVW    R17 : R16,R25 : R24
   \   00000064   ........                   CALL    MemCpy
    125          			return;																																							// ...and break out
   \   00000068   C03C                       RJMP    ??ARP_Cache_2
    126          		}
    127          		
    128          		if(arpTable[temp].age < arpTable[Oldest].age)
   \                     ??ARP_Cache_1:
   \   0000006A   8542                       LDD     R20,Z+10
   \   0000006C   8553                       LDD     R21,Z+11
   \   0000006E   E010                       LDI     R17,0
   \   00000070   E02C                       LDI     R18,12
   \   00000072   E030                       LDI     R19,0
   \   00000074   9F30                       MUL     R19,R16
   \   00000076   2D30                       MOV     R19,R0
   \   00000078   9F21                       MUL     R18,R17
   \   0000007A   0D30                       ADD     R19,R0
   \   0000007C   9F20                       MUL     R18,R16
   \   0000007E   2D20                       MOV     R18,R0
   \   00000080   0D31                       ADD     R19,R1
   \   00000082   01F9                       MOVW    R31 : R30,R19 : R18
   \   00000084   ....                       SUBI    R30,LOW((-(arpTable) & 0xFFFF))
   \   00000086   ....                       SBCI    R31,(-(arpTable) & 0xFFFF) >> 8
   \   00000088   8522                       LDD     R18,Z+10
   \   0000008A   8533                       LDD     R19,Z+11
   \   0000008C   1742                       CP      R20,R18
   \   0000008E   0753                       CPC     R21,R19
   \   00000090   F408                       BRCC    ??ARP_Cache_3
    129          		{
    130          			Oldest=temp;
   \   00000092   2F0A                       MOV     R16,R26
   \                     ??ARP_Cache_3:
   \   00000094   95A3                       INC     R26
   \   00000096   30A3                       CPI     R26,3
   \   00000098   F408                       BRCC    ??ARP_Cache_4
   \   0000009A   CFBD                       RJMP    ??ARP_Cache_0
    131          		}
    132          	}
    133          
    134          	arpTable[Oldest].ip = ip;																														// Owerwrite the oldest entry
   \                     ??ARP_Cache_4:
   \   0000009C   ....                       LDI     R26,LOW(arpTable)
   \   0000009E   ....                       LDI     R27,(arpTable) >> 8
   \   000000A0   2F20                       MOV     R18,R16
   \   000000A2   E030                       LDI     R19,0
   \   000000A4   E00C                       LDI     R16,12
   \   000000A6   9F12                       MUL     R17,R18
   \   000000A8   2D10                       MOV     R17,R0
   \   000000AA   9F03                       MUL     R16,R19
   \   000000AC   0D10                       ADD     R17,R0
   \   000000AE   9F02                       MUL     R16,R18
   \   000000B0   0D11                       ADD     R17,R1
   \   000000B2   0DA0                       ADD     R26,R0
   \   000000B4   1FB1                       ADC     R27,R17
   \   000000B6   ....                       LDI     R30,LOW(ip)
   \   000000B8   ....                       LDI     R31,(ip) >> 8
   \   000000BA   8100                       LD      R16,Z
   \   000000BC   8111                       LDD     R17,Z+1
   \   000000BE   930D                       ST      X+,R16
   \   000000C0   931D                       ST      X+,R17
   \   000000C2   922D                       ST      X+,R2
   \   000000C4   923C                       ST      X,R3
   \   000000C6   9713                       SBIW    R27 : R26,3
    135          	MemCpy(buffer + ETHERNET_SOURCE, arpTable[Oldest].mac, 6);
   \   000000C8   E046                       LDI     R20,6
   \   000000CA   E050                       LDI     R21,0
   \   000000CC   019D                       MOVW    R19 : R18,R27 : R26
   \   000000CE   5F2C                       SUBI    R18,252
   \   000000D0   4F3F                       SBCI    R19,255
   \   000000D2   9606                       ADIW    R25 : R24,6
   \   000000D4   018C                       MOVW    R17 : R16,R25 : R24
   \   000000D6   ........                   CALL    MemCpy
    136          	arpTable[Oldest].age = ~0;
   \   000000DA   EF0F                       LDI     R16,255
   \   000000DC   01FD                       MOVW    R31 : R30,R27 : R26
   \   000000DE   8702                       STD     Z+10,R16
   \   000000E0   8703                       STD     Z+11,R16
   \                     ??ARP_Cache_2:
   \   000000E2   9189                       LD      R24,Y+
   \   000000E4   9199                       LD      R25,Y+
   \   000000E6   91A9                       LD      R26,Y+
   \   000000E8   91B9                       LD      R27,Y+
   \   000000EA   9508                       RET
    137          }
    138          
    139          

   \                                 In segment CODE, align 2, keep-with-next
    140          unsigned char *ARP_LookUp(unsigned long theIP)
    141          {
    142          unsigned char temp;
    143          
    144          	for(temp = 0 ; temp < ARP_TABLE_SIZE ; temp++)
   \   __nearfunc unsigned char *ARP_LookUp(unsigned long);
   \                     ARP_LookUp:
   \   00000000   E040                       LDI     R20,0
    145          	{
    146          		if(arpTable[temp].ip == theIP)
   \                     ??ARP_LookUp_0:
   \   00000002   ....                       LDI     R30,LOW(arpTable)
   \   00000004   ....                       LDI     R31,(arpTable) >> 8
   \   00000006   E050                       LDI     R21,0
   \   00000008   E06C                       LDI     R22,12
   \   0000000A   E070                       LDI     R23,0
   \   0000000C   9F74                       MUL     R23,R20
   \   0000000E   2D70                       MOV     R23,R0
   \   00000010   9F65                       MUL     R22,R21
   \   00000012   0D70                       ADD     R23,R0
   \   00000014   9F64                       MUL     R22,R20
   \   00000016   0D71                       ADD     R23,R1
   \   00000018   0DE0                       ADD     R30,R0
   \   0000001A   1FF7                       ADC     R31,R23
   \   0000001C   8000                       LD      R0,Z
   \   0000001E   8011                       LDD     R1,Z+1
   \   00000020   8022                       LDD     R2,Z+2
   \   00000022   8033                       LDD     R3,Z+3
   \   00000024   1600                       CP      R0,R16
   \   00000026   0611                       CPC     R1,R17
   \   00000028   0622                       CPC     R2,R18
   \   0000002A   0633                       CPC     R3,R19
   \   0000002C   F419                       BRNE    ??ARP_LookUp_1
    147          		{
    148          			return arpTable[temp].mac;
   \   0000002E   9634                       ADIW    R31 : R30,4
   \   00000030   018F                       MOVW    R17 : R16,R31 : R30
   \   00000032   9508                       RET
   \                     ??ARP_LookUp_1:
   \   00000034   9543                       INC     R20
   \   00000036   3043                       CPI     R20,3
   \   00000038   F320                       BRCS    ??ARP_LookUp_0
    149          		}
    150          	}
    151          	
    152          	return NULL;
   \   0000003A   E000                       LDI     R16,0
   \   0000003C   E010                       LDI     R17,0
   \   0000003E   9508                       RET
    153          }

   Maximum stack usage in bytes:

     Function            CSTACK  RSTACK
     --------            ------  ------
     ARP_Cache               4       2 
       -> GetLong            4       2 
       -> MemCpy             4       2 
       -> MemCpy             4       2 
     ARP_LookUp              0       0 
     ARP_Receive             4       2 
       -> GetShort           4       2 
       -> GetShort           4       2 
       -> GetShort           4       2 
       -> GetLong            4       2 
       -> PutShort           4       2 
       -> Swap               4       2 
       -> Clear              4       2 
       -> ETHERNET_Send      4       2 
       -> ARP_Cache          4       2 
     ARP_Request             0       0 
     ARP_Tick                0       2 
       -> Kernel_Sleep       0       2 

 
    564 bytes in segment CODE
      6 bytes in segment INITTAB
     36 bytes in segment NEAR_Z
 
    564 bytes of CODE memory (+ 6 bytes shared)
     36 bytes of DATA memory

Errors: none
Warnings: none
